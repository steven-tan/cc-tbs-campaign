<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fantasy Tactical Battle</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a2e;
  color: #eee;
  font-family: 'Segoe UI', system-ui, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 20px;
  user-select: none;
}
#header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  max-width: 100%;
}
#turn-info { font-size: 18px; font-weight: bold; }
#end-turn {
  padding: 8px 20px;
  font-size: 14px;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  font-weight: bold;
  transition: opacity 0.2s;
}
#end-turn:hover { opacity: 0.85; }
#end-turn:disabled { opacity: 0.5; cursor: default; }
canvas { border: 2px solid #333; cursor: pointer; display: block; max-width: 100%; height: auto; }
#info-panel {
  margin-top: 10px;
  padding: 10px;
  background: #16213e;
  border-radius: 4px;
  min-height: 40px;
  font-size: 14px;
  line-height: 1.4;
  max-width: 100%;
}
#help-btn {
  padding: 8px 16px;
  font-size: 14px;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  font-weight: bold;
  background: #555;
  color: #fff;
  transition: opacity 0.2s;
}
#help-btn:hover { opacity: 0.85; }
#help-panel {
  margin-top: 10px;
  padding: 14px 18px;
  background: #16213e;
  border-radius: 4px;
  font-size: 13px;
  line-height: 1.5;
  display: none;
  max-width: 100%;
  overflow-x: auto;
}
#help-panel table {
  border-collapse: collapse;
  margin: 8px 0;
}
#help-panel th, #help-panel td {
  border: 1px solid #334;
  padding: 4px 10px;
  text-align: center;
}
#help-panel th {
  background: #1a2440;
}
#help-panel h3 {
  margin: 10px 0 4px;
  font-size: 14px;
  color: #8cf;
}
#help-panel h3:first-child { margin-top: 0; }
</style>
</head>
<body>
<div id="header">
  <span id="turn-info"></span>
  <div>
    <button id="help-btn">Help</button>
    <button id="end-turn">End Turn</button>
  </div>
</div>
<canvas id="game"></canvas>
<div id="info-panel">Click a unit to select it.</div>
<div id="help-panel">
  <h3>Units</h3>
  <table>
    <tr><th>Unit</th><th>HP</th><th>Move</th><th>Range</th></tr>
    <tr><td>Swordsman (S)</td><td>100</td><td>3</td><td>1</td></tr>
    <tr><td>Spearman (P)</td><td>100</td><td>3</td><td>1</td></tr>
    <tr><td>Archer (A)</td><td>100</td><td>3</td><td>2</td></tr>
    <tr><td>Cavalry (C)</td><td>100</td><td>4</td><td>1</td></tr>
  </table>
  <h3>Damage (attacker vs defender) — bold = strong matchup</h3>
  <table>
    <tr><th></th><th>vs Sword</th><th>vs Spear</th><th>vs Archer</th><th>vs Cav</th></tr>
    <tr><th>Swordsman</th><td>55</td><td><b>70</b></td><td>55</td><td>55</td></tr>
    <tr><th>Spearman</th><td>55</td><td>55</td><td>55</td><td><b>70</b></td></tr>
    <tr><th>Archer</th><td>55</td><td>55</td><td>55</td><td><b>70</b></td></tr>
    <tr><th>Cavalry</th><td><b>70</b></td><td>55</td><td><b>70</b></td><td>55</td></tr>
  </table>
  <h3>Terrain</h3>
  <table>
    <tr><th>Terrain</th><th>Defense</th><th>Sw cost</th><th>Sp cost</th><th>Arch cost</th><th>Cav cost</th></tr>
    <tr><td>Plains</td><td>+0%</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
    <tr><td>Mountains</td><td>+30%</td><td>3</td><td>3</td><td>3</td><td>—</td></tr>
    <tr><td>Forest</td><td>+30%</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
    <tr><td>Water</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
  </table>
  <h3>Combat notes</h3>
  <p>Damaged units deal less damage (down to ~50% at very low HP). Defenders counter-attack if the attacker is within their range. Mountains and forests reduce incoming damage by 30%. Water is impassable. Cavalry cannot enter mountains. Swordsmen are strong vs spearmen. Spearmen and archers are strong vs cavalry. Cavalry is strong vs swordsmen and archers.</p>
</div>

<script>
// ============================================================
//  DATA DEFINITIONS — Constants that define game rules.
//  Edit these to tune gameplay without touching logic.
// ============================================================

const COLS = 9, ROWS = 9;

const TERRAIN = { PLAINS: 'plains', MOUNTAINS: 'mountains', FOREST: 'forest', WATER: 'water' };
const TEAM   = { BLUE: 1, RED: 2 };
const PHASE  = { SELECT: 'select', MOVE: 'move', ATTACK: 'attack' };

const TEAM_NAME  = { [TEAM.BLUE]: 'Blue', [TEAM.RED]: 'Red' };
const TEAM_COLOR = { [TEAM.BLUE]: '#4488ff', [TEAM.RED]: '#ff4444' };

const UNIT_DEFS = {
  swordsman: { name: 'Swordsman', hp: 100, move: 3, range: 1 },
  spearman:  { name: 'Spearman',  hp: 100, move: 3, range: 1 },
  archer:    { name: 'Archer',    hp: 100, move: 3, range: 2 },
  cavalry:   { name: 'Cavalry',   hp: 100, move: 4, range: 1 },
};

const TERRAIN_DEFS = {
  [TERRAIN.PLAINS]:    { name: 'Plains',    defense: 0,  moveCost: { swordsman: 1, spearman: 1, archer: 1, cavalry: 1 } },
  [TERRAIN.MOUNTAINS]: { name: 'Mountains', defense: 30, moveCost: { swordsman: 3, spearman: 3, archer: 3, cavalry: Infinity } },
  [TERRAIN.FOREST]:    { name: 'Forest',    defense: 30, moveCost: { swordsman: 2, spearman: 2, archer: 2, cavalry: 2 } },
  [TERRAIN.WATER]:     { name: 'Water',     defense: 0,  moveCost: { swordsman: Infinity, spearman: Infinity, archer: Infinity, cavalry: Infinity } },
};

// Base damage: DAMAGE_TABLE[attackerType][defenderType]
const DAMAGE_TABLE = {
  swordsman: { swordsman: 55, spearman: 70, archer: 55, cavalry: 55 },
  spearman:  { swordsman: 55, spearman: 55, archer: 55, cavalry: 70 },
  archer:    { swordsman: 55, spearman: 55, archer: 55, cavalry: 70 },
  cavalry:   { swordsman: 70, spearman: 55, archer: 70, cavalry: 55 },
};

// ============================================================
//  HEX GRID — Pointy-top hexes, odd-r offset coordinates.
//  Odd rows are shifted right by half a hex width.
// ============================================================

const HEX_SIZE = 34;                        // center to vertex
const SQRT3   = Math.sqrt(3);
const HEX_W   = SQRT3 * HEX_SIZE;           // hex width (flat-to-flat)
const HEX_H   = 2 * HEX_SIZE;               // hex height (point-to-point)

// 6 neighbor offsets, indexed by row parity: [even-row, odd-row]
const HEX_DIRS = [
  [[-1,-1], [-1, 0], [0,-1], [0, 1], [1,-1], [1, 0]],   // even rows
  [[-1, 0], [-1, 1], [0,-1], [0, 1], [1, 0], [1, 1]],   // odd rows
];

/** Returns in-bounds hex neighbors for a cell at (row, col). */
function hexNeighbors(row, col) {
  const dirs = HEX_DIRS[row & 1];
  const result = [];
  for (const [dr, dc] of dirs) {
    const nr = row + dr, nc = col + dc;
    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) result.push({ row: nr, col: nc });
  }
  return result;
}

/** Convert offset (row, col) to pixel center of the hex. */
function hexToPixel(row, col) {
  return {
    x: HEX_W * (col + 0.5 * (row & 1)) + HEX_W / 2,
    y: HEX_SIZE * 1.5 * row + HEX_SIZE,
  };
}

/** Convert pixel position to offset (row, col) via axial rounding. */
function pixelToHex(px, py) {
  // Undo the origin offset to get coords relative to hex (0,0) center
  const x = px - HEX_W / 2;
  const y = py - HEX_SIZE;
  // Pixel to fractional axial (pointy-top)
  const q = (SQRT3 / 3 * x - y / 3) / HEX_SIZE;
  const r = (2 / 3 * y) / HEX_SIZE;
  // Cube round
  const s = -q - r;
  let rq = Math.round(q), rr = Math.round(r), rs = Math.round(s);
  const dq = Math.abs(rq - q), dr = Math.abs(rr - r), ds = Math.abs(rs - s);
  if (dq > dr && dq > ds) rq = -rr - rs;
  else if (dr > ds)        rr = -rq - rs;
  // Axial to offset (odd-r)
  const col = rq + (rr - (rr & 1)) / 2;
  const row = rr;
  if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
  return { row, col };
}

/** Hex distance between two offset cells (via cube coordinates). */
function hexDistance(r1, c1, r2, c2) {
  const x1 = c1 - (r1 - (r1 & 1)) / 2, z1 = r1, y1 = -x1 - z1;
  const x2 = c2 - (r2 - (r2 & 1)) / 2, z2 = r2, y2 = -x2 - z2;
  return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));
}

// Canvas dimensions to fit the hex grid exactly
const CANVAS_W = Math.ceil(HEX_W * (COLS + 0.5));
const CANVAS_H = Math.ceil(HEX_SIZE * (1.5 * ROWS + 0.5));

// ============================================================
//  GAME STATE — Pure data container, fully serializable.
//  No methods with side effects. No DOM references.
// ============================================================

class GameState {
  constructor() {
    this.map = [];               // 2D array of TERRAIN values
    this.units = [];             // Array of unit objects
    this.currentTeam = TEAM.BLUE;
    this.turnNumber = 1;
    this.phase = PHASE.SELECT;
    this.selectedUnitId = null;
    this.highlightedMoves = [];  // [{row, col}]
    this.highlightedAttacks = []; // [unitId]
    this.winner = null;
  }

  static createInitial(mapData, unitData) {
    const s = new GameState();
    s.map = mapData;
    s.units = unitData.map((u, i) => ({
      id: i, type: u.type, team: u.team,
      row: u.row, col: u.col,
      hp: UNIT_DEFS[u.type].hp, moved: false, attacked: false,
    }));
    return s;
  }

  getUnit(id)        { return this.units.find(u => u.id === id); }
  getUnitAt(row, col) { return this.units.find(u => u.row === row && u.col === col && u.hp > 0); }
  getLivingUnits(team) { return this.units.filter(u => u.team === team && u.hp > 0); }

  serialize()              { return JSON.parse(JSON.stringify(this)); }
  static deserialize(json) { return Object.assign(new GameState(), JSON.parse(JSON.stringify(json))); }
}

// ============================================================
//  GAME RULES — Pure functions operating on GameState.
//  No side effects, no DOM, no rendering. Fully testable.
// ============================================================

class GameRules {

  /** Returns all cells a unit can move to, respecting terrain and occupancy. */
  static getMovableCells(state, unit) {
    const maxMove = UNIT_DEFS[unit.type].move;
    const visited = new Map();
    const queue = [{ row: unit.row, col: unit.col, remaining: maxMove }];
    visited.set(`${unit.row},${unit.col}`, maxMove);

    while (queue.length > 0) {
      const { row, col, remaining } = queue.shift();
      for (const nb of hexNeighbors(row, col)) {
        const cost = TERRAIN_DEFS[state.map[nb.row][nb.col]].moveCost[unit.type];
        if (cost === Infinity) continue;
        const rem = remaining - cost;
        if (rem < 0) continue;
        const key = `${nb.row},${nb.col}`;
        if (visited.has(key) && visited.get(key) >= rem) continue;
        const occ = state.getUnitAt(nb.row, nb.col);
        if (occ && occ.team !== unit.team) continue;
        visited.set(key, rem);
        queue.push({ row: nb.row, col: nb.col, remaining: rem });
      }
    }

    const cells = [];
    for (const [key] of visited) {
      const [r, c] = key.split(',').map(Number);
      const occ = state.getUnitAt(r, c);
      if (occ && occ.id !== unit.id) continue;
      cells.push({ row: r, col: c });
    }
    return cells;
  }

  /** Returns enemy units within attack range. */
  static getAttackTargets(state, unit) {
    const range = UNIT_DEFS[unit.type].range;
    const targets = [];
    for (const other of state.units) {
      if (other.hp <= 0 || other.team === unit.team) continue;
      if (hexDistance(unit.row, unit.col, other.row, other.col) <= range) {
        targets.push(other);
      }
    }
    return targets;
  }

  static calculateDamage(attackerType, attackerHp, defenderType, defenderTerrain) {
    const base = DAMAGE_TABLE[attackerType][defenderType];
    const atkMod = 0.5 + 0.5 * (attackerHp / 100);
    const defBonus = TERRAIN_DEFS[defenderTerrain].defense;
    return Math.max(1, Math.round(base * atkMod * (100 - defBonus) / 100));
  }

  static resolveAttack(state, attackerId, defenderId) {
    const atk = state.getUnit(attackerId);
    const def = state.getUnit(defenderId);
    const defTerrain = state.map[def.row][def.col];
    const atkTerrain = state.map[atk.row][atk.col];

    const damage = this.calculateDamage(atk.type, atk.hp, def.type, defTerrain);
    def.hp = Math.max(0, def.hp - damage);

    let counterDamage = 0;
    const dist = hexDistance(atk.row, atk.col, def.row, def.col);
    if (def.hp > 0 && dist <= UNIT_DEFS[def.type].range) {
      counterDamage = this.calculateDamage(def.type, def.hp, atk.type, atkTerrain);
      atk.hp = Math.max(0, atk.hp - counterDamage);
    }

    return {
      damage, counterDamage,
      defenderDestroyed: def.hp <= 0,
      attackerDestroyed: atk.hp <= 0,
    };
  }

  static moveUnit(state, unitId, toRow, toCol) {
    const unit = state.getUnit(unitId);
    unit.row = toRow;
    unit.col = toCol;
  }

  static endTurn(state) {
    for (const u of state.getLivingUnits(state.currentTeam)) { u.moved = false; u.attacked = false; }
    state.currentTeam = state.currentTeam === TEAM.BLUE ? TEAM.RED : TEAM.BLUE;
    if (state.currentTeam === TEAM.BLUE) state.turnNumber++;
    state.phase = PHASE.SELECT;
    state.selectedUnitId = null;
    state.highlightedMoves = [];
    state.highlightedAttacks = [];
  }

  static checkWinner(state) {
    if (state.getLivingUnits(TEAM.BLUE).length === 0) return TEAM.RED;
    if (state.getLivingUnits(TEAM.RED).length === 0) return TEAM.BLUE;
    return null;
  }
}

// ============================================================
//  RENDERER — Canvas hex renderer. Swap this class to change
//  rendering tech (Canvas → WebGL, DOM, terminal, etc.)
// ============================================================

class CanvasRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;
  }

  /** Trace a pointy-top hex path centered at (cx, cy). */
  hexPath(cx, cy, size) {
    const ctx = this.ctx;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = Math.PI / 3 * i - Math.PI / 2;
      const vx = cx + size * Math.cos(angle);
      const vy = cy + size * Math.sin(angle);
      if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
    }
    ctx.closePath();
  }

  render(state, hoverCell) {
    const ctx = this.ctx;
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // Background fill (visible in gaps if any)
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    const moveSet = new Set(state.highlightedMoves.map(c => `${c.row},${c.col}`));
    const attackSet = new Set(state.highlightedAttacks);

    // -- Terrain hexes --
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const { x: cx, y: cy } = hexToPixel(r, c);
        const terrain = state.map[r][c];

        // Base terrain fill (slightly oversized to avoid seams)
        this.hexPath(cx, cy, HEX_SIZE + 0.5);
        if (terrain === TERRAIN.MOUNTAINS) {
          ctx.fillStyle = '#7a6548';
        } else if (terrain === TERRAIN.FOREST) {
          ctx.fillStyle = (r + c) % 2 === 0 ? '#3a7a30' : '#2e6828';
        } else if (terrain === TERRAIN.WATER) {
          ctx.fillStyle = (r + c) % 2 === 0 ? '#2266aa' : '#1d5a96';
        } else {
          ctx.fillStyle = (r + c) % 2 === 0 ? '#7ec850' : '#6ab040';
        }
        ctx.fill();

        // Terrain decorations
        if (terrain === TERRAIN.MOUNTAINS) {
          const s = HEX_SIZE * 0.55;
          ctx.fillStyle = '#9a8060';
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.7, cy + s * 0.6);
          ctx.lineTo(cx,           cy - s * 0.7);
          ctx.lineTo(cx + s * 0.7, cy + s * 0.6);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#d4c8b0';
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.22, cy - s * 0.3);
          ctx.lineTo(cx,            cy - s * 0.7);
          ctx.lineTo(cx + s * 0.22, cy - s * 0.3);
          ctx.closePath();
          ctx.fill();
        } else if (terrain === TERRAIN.FOREST) {
          const s = HEX_SIZE * 0.35;
          // Left tree
          ctx.fillStyle = '#2a5a20';
          ctx.beginPath();
          ctx.moveTo(cx - s * 1.2, cy + s * 0.7);
          ctx.lineTo(cx - s * 0.5, cy - s * 0.8);
          ctx.lineTo(cx + s * 0.2, cy + s * 0.7);
          ctx.closePath();
          ctx.fill();
          // Right tree
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy + s * 0.7);
          ctx.lineTo(cx + s * 0.6, cy - s * 1.0);
          ctx.lineTo(cx + s * 1.3, cy + s * 0.7);
          ctx.closePath();
          ctx.fill();
        } else if (terrain === TERRAIN.WATER) {
          // Wave lines
          ctx.strokeStyle = 'rgba(100, 180, 255, 0.4)';
          ctx.lineWidth = 1.5;
          const w = HEX_SIZE * 0.4;
          for (let wy = -1; wy <= 1; wy++) {
            ctx.beginPath();
            ctx.moveTo(cx - w, cy + wy * 8);
            ctx.quadraticCurveTo(cx - w * 0.5, cy + wy * 8 - 4, cx, cy + wy * 8);
            ctx.quadraticCurveTo(cx + w * 0.5, cy + wy * 8 + 4, cx + w, cy + wy * 8);
            ctx.stroke();
          }
          ctx.lineWidth = 1;
        }

        // Movement highlight
        if (moveSet.has(`${r},${c}`)) {
          this.hexPath(cx, cy, HEX_SIZE);
          ctx.fillStyle = 'rgba(100, 180, 255, 0.35)';
          ctx.fill();
        }

        // Hover highlight
        if (hoverCell && hoverCell.row === r && hoverCell.col === c) {
          this.hexPath(cx, cy, HEX_SIZE);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.12)';
          ctx.fill();
        }

        // Hex outline
        this.hexPath(cx, cy, HEX_SIZE);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    // -- Units --
    for (const unit of state.units) {
      if (unit.hp <= 0) continue;
      const { x: cx, y: cy } = hexToPixel(unit.row, unit.col);
      const isSelected = unit.id === state.selectedUnitId;
      const isTarget = attackSet.has(unit.id);

      // Attack target overlay
      if (isTarget) {
        this.hexPath(cx, cy, HEX_SIZE);
        ctx.fillStyle = 'rgba(255, 60, 60, 0.4)';
        ctx.fill();
        this.hexPath(cx, cy, HEX_SIZE - 2);
        ctx.strokeStyle = 'rgba(255, 60, 60, 0.8)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.lineWidth = 1;
      }

      const radius = HEX_SIZE * 0.38;

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.arc(cx + 2, cy + 2, radius, 0, Math.PI * 2);
      ctx.fill();

      // Unit circle — fresh / moved / done
      let color = TEAM_COLOR[unit.team];
      if (unit.attacked)                    color = unit.team === TEAM.BLUE ? '#445570' : '#704545';
      else if (unit.moved && !unit.attacked) color = unit.team === TEAM.BLUE ? '#3a6ab8' : '#b85a4a';
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.4)';
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.lineWidth = 1;

      // Selection ring
      if (isSelected) {
        ctx.strokeStyle = '#ffdd00';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(cx, cy, radius + 4, 0, Math.PI * 2);
        ctx.stroke();
        ctx.lineWidth = 1;
      }

      // Unit letter
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${HEX_SIZE * 0.5}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const unitLetter = { swordsman: 'S', spearman: 'P', archer: 'A', cavalry: 'C' };
      ctx.fillText(unitLetter[unit.type], cx, cy);

      // HP bar
      const barW = HEX_SIZE * 0.9, barH = 4;
      const barX = cx - barW / 2, barY = cy + radius + 6;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
      const hpPct = unit.hp / UNIT_DEFS[unit.type].hp;
      ctx.fillStyle = hpPct > 0.5 ? '#4c4' : hpPct > 0.25 ? '#cc4' : '#c44';
      ctx.fillRect(barX, barY, barW * hpPct, barH);

      // HP number
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${HEX_SIZE * 0.28}px sans-serif`;
      ctx.fillText(unit.hp, cx + radius + 2, cy + radius + 6);
    }
  }

  getCellFromPixel(clientX, clientY) {
    const rect = this.canvas.getBoundingClientRect();
    return pixelToHex(clientX - rect.left, clientY - rect.top);
  }
}

// ============================================================
//  GAME CONTROLLER — Wires input, rules, state, and renderer.
//  To add AI: check currentTeam before waiting for clicks.
//  To add networking: sync state after each action.
//  To add save/load: serialize/deserialize GameState.
// ============================================================

class GameController {
  constructor() {
    this.state = this.createInitialState();
    const canvas = document.getElementById('game');
    this.renderer = new CanvasRenderer(canvas);
    this.turnInfoEl = document.getElementById('turn-info');
    this.endTurnBtn = document.getElementById('end-turn');
    this.infoPanel = document.getElementById('info-panel');
    this.hoverCell = null;

    // Size header/panel to match canvas
    const w = canvas.width + 'px';
    document.getElementById('header').style.width = w;
    this.infoPanel.style.width = w;
    const helpPanel = document.getElementById('help-panel');
    helpPanel.style.width = w;
    const helpBtn = document.getElementById('help-btn');
    helpBtn.addEventListener('click', () => {
      const open = helpPanel.style.display !== 'none';
      helpPanel.style.display = open ? 'none' : 'block';
      helpBtn.textContent = open ? 'Help' : 'Hide Help';
    });

    this.bindInput();
    this.updateUI();
  }

  createInitialState() {
    const P = TERRAIN.PLAINS, M = TERRAIN.MOUNTAINS, F = TERRAIN.FOREST, W = TERRAIN.WATER;
    const map = [
      [P, P, P, P, P, P, P, P, P],
      [P, P, M, P, F, F, P, M, P],
      [P, P, M, P, P, F, P, P, P],
      [F, F, P, P, P, P, P, F, F],
      [P, P, P, W, W, P, P, P, P],
      [F, F, P, P, P, P, P, F, F],
      [P, P, P, F, P, P, M, P, P],
      [P, M, P, F, F, P, M, P, P],
      [P, P, P, P, P, P, P, P, P],
    ];
    const units = [
      { type: 'cavalry',   team: TEAM.BLUE, row: 8, col: 0 },
      { type: 'swordsman', team: TEAM.BLUE, row: 8, col: 1 },
      { type: 'spearman',  team: TEAM.BLUE, row: 8, col: 3 },
      { type: 'archer',    team: TEAM.BLUE, row: 8, col: 4 },
      { type: 'archer',    team: TEAM.BLUE, row: 8, col: 5 },
      { type: 'swordsman', team: TEAM.BLUE, row: 8, col: 7 },
      { type: 'cavalry',   team: TEAM.BLUE, row: 8, col: 8 },
      { type: 'cavalry',   team: TEAM.RED,  row: 0, col: 0 },
      { type: 'swordsman', team: TEAM.RED,  row: 0, col: 1 },
      { type: 'archer',    team: TEAM.RED,  row: 0, col: 3 },
      { type: 'archer',    team: TEAM.RED,  row: 0, col: 4 },
      { type: 'spearman',  team: TEAM.RED,  row: 0, col: 6 },
      { type: 'swordsman', team: TEAM.RED,  row: 0, col: 7 },
      { type: 'cavalry',   team: TEAM.RED,  row: 0, col: 8 },
    ];
    return GameState.createInitial(map, units);
  }

  // -- Input binding (swap this section for AI/network input) --

  bindInput() {
    const canvas = this.renderer.canvas;
    canvas.addEventListener('click', (e) => {
      if (this.state.winner) return;
      const cell = this.renderer.getCellFromPixel(e.clientX, e.clientY);
      if (cell) this.handleClick(cell.row, cell.col);
    });
    canvas.addEventListener('mousemove', (e) => {
      this.hoverCell = this.renderer.getCellFromPixel(e.clientX, e.clientY);
      this.renderOnly();
    });
    canvas.addEventListener('mouseleave', () => {
      this.hoverCell = null;
      this.renderOnly();
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') { this.cancelSelection(); this.updateUI(); }
    });
    this.endTurnBtn.addEventListener('click', () => {
      if (this.state.winner) return;
      this.doEndTurn();
    });
  }

  // -- Action handlers --

  handleClick(row, col) {
    const s = this.state;
    if      (s.phase === PHASE.SELECT) this.doSelect(row, col);
    else if (s.phase === PHASE.MOVE)   this.doMove(row, col);
    else if (s.phase === PHASE.ATTACK) this.doAttack(row, col);
  }

  doSelect(row, col) {
    const s = this.state;
    const unit = s.getUnitAt(row, col);
    if (!unit || unit.team !== s.currentTeam) return;
    if (unit.moved && unit.attacked) return; // fully done

    s.selectedUnitId = unit.id;

    if (unit.moved && !unit.attacked) {
      // Already moved — attack phase only
      const targets = GameRules.getAttackTargets(s, unit);
      if (targets.length > 0) {
        s.highlightedAttacks = targets.map(t => t.id);
        s.phase = PHASE.ATTACK;
        this.setInfo(`${UNIT_DEFS[unit.type].name}: click an enemy to attack, or elsewhere to wait.`);
      } else {
        this.cancelSelection();
        this.setInfo(`${UNIT_DEFS[unit.type].name}: no targets in range.`);
      }
    } else {
      // Can move — show movement range
      s.highlightedMoves = GameRules.getMovableCells(s, unit);
      // If hasn't attacked yet, also show attack targets (fire before move)
      if (!unit.attacked) {
        const targets = GameRules.getAttackTargets(s, unit);
        s.highlightedAttacks = targets.map(t => t.id);
      }
      s.phase = PHASE.MOVE;
      const name = UNIT_DEFS[unit.type].name;
      if (unit.attacked) {
        this.setInfo(`${name}: click a cell to move, or elsewhere to cancel.`);
      } else {
        this.setInfo(`${name} selected (HP: ${unit.hp}). Move, attack an adjacent enemy, or click elsewhere to cancel.`);
      }
    }
    this.updateUI();
  }

  doMove(row, col) {
    const s = this.state;
    const unit = s.getUnit(s.selectedUnitId);

    // Fire before move — click an adjacent enemy
    const target = s.getUnitAt(row, col);
    if (target && s.highlightedAttacks.includes(target.id)) {
      this.performAttack(unit, target);
      return;
    }

    // Click own unit = deselect
    if (row === unit.row && col === unit.col) {
      this.cancelSelection();
      this.updateUI();
      return;
    }

    // Valid move destination
    if (s.highlightedMoves.some(c => c.row === row && c.col === col)) {
      GameRules.moveUnit(s, unit.id, row, col);
      unit.moved = true;
      const name = UNIT_DEFS[unit.type].name;
      if (!unit.attacked) {
        const targets = GameRules.getAttackTargets(s, unit);
        if (targets.length > 0) {
          s.highlightedMoves = [];
          s.highlightedAttacks = targets.map(t => t.id);
          s.phase = PHASE.ATTACK;
          this.setInfo(`${name} moved. Click an enemy to attack, or elsewhere to cancel.`);
          this.updateUI();
          return;
        }
      }
      this.cancelSelection();
      this.setInfo(`${name} moved.`);
      this.checkAllActed();
      this.updateUI();
      return;
    }

    // Clicked elsewhere — cancel and try selecting what was clicked
    this.cancelSelection();
    this.doSelect(row, col);
  }

  doAttack(row, col) {
    const s = this.state;
    const attacker = s.getUnit(s.selectedUnitId);
    const target = s.getUnitAt(row, col);

    if (target && s.highlightedAttacks.includes(target.id)) {
      this.performAttack(attacker, target);
    } else {
      // Click elsewhere — cancel, try selecting what was clicked
      this.cancelSelection();
      this.doSelect(row, col);
    }
  }

  /** Shared combat resolution for both fire-before-move and fire-after-move. */
  performAttack(attacker, target) {
    const s = this.state;
    const result = GameRules.resolveAttack(s, attacker.id, target.id);
    let msg = `${TEAM_NAME[attacker.team]} ${UNIT_DEFS[attacker.type].name} deals ${result.damage} dmg`;
    if (result.defenderDestroyed) {
      msg += ` — ${UNIT_DEFS[target.type].name} destroyed!`;
    } else {
      msg += ` (enemy HP: ${target.hp})`;
      if (result.counterDamage > 0) {
        msg += `. Counter-attack: ${result.counterDamage} dmg`;
        if (result.attackerDestroyed) {
          msg += ` — ${UNIT_DEFS[attacker.type].name} destroyed!`;
        } else {
          msg += ` (HP: ${attacker.hp})`;
        }
      }
    }

    attacker.attacked = true;
    this.cancelSelection();

    const winner = GameRules.checkWinner(s);
    if (winner) {
      s.winner = winner;
      this.setInfo(`${TEAM_NAME[s.winner]} team wins!`);
    } else {
      if (!attacker.moved && attacker.hp > 0) msg += ' Select again to move.';
      this.setInfo(msg);
      this.checkAllActed();
    }
    this.updateUI();
  }

  doEndTurn() {
    GameRules.endTurn(this.state);
    this.setInfo(`${TEAM_NAME[this.state.currentTeam]}'s turn. Select a unit.`);
    this.updateUI();
  }

  // -- Helpers --

  cancelSelection() {
    const s = this.state;
    s.selectedUnitId = null;
    s.highlightedMoves = [];
    s.highlightedAttacks = [];
    s.phase = PHASE.SELECT;
  }

  checkAllActed() {
    const s = this.state;
    if (s.getLivingUnits(s.currentTeam).every(u => u.attacked)) {
      this.setInfo(this.infoPanel.textContent + ' All units done — click End Turn.');
    }
  }

  setInfo(text) { this.infoPanel.textContent = text; }

  renderOnly() { this.renderer.render(this.state, this.hoverCell); }

  updateUI() {
    const s = this.state;
    const color = TEAM_COLOR[s.currentTeam];
    if (s.winner) {
      this.turnInfoEl.innerHTML = `<span style="color:${TEAM_COLOR[s.winner]}">${TEAM_NAME[s.winner]} Wins!</span>`;
      this.endTurnBtn.disabled = true;
    } else {
      this.turnInfoEl.innerHTML = `Turn ${s.turnNumber} — <span style="color:${color}">${TEAM_NAME[s.currentTeam]}</span>`;
      this.endTurnBtn.style.background = color;
      this.endTurnBtn.style.color = '#fff';
    }
    this.renderer.render(this.state, this.hoverCell);
  }
}

// ============================================================
//  BOOT
// ============================================================

const game = new GameController();
</script>
</body>
</html>
