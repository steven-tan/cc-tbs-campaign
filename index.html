<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fantasy Tactical Battle</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #1a1a2e;
  color: #eee;
  font-family: 'Segoe UI', system-ui, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 20px;
  user-select: none;
}
#header {
  display: none;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
  max-width: 100%;
}
#turn-info { font-size: 18px; font-weight: bold; }
#end-turn {
  padding: 8px 20px;
  font-size: 14px;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  font-weight: bold;
  transition: opacity 0.2s;
}
#end-turn:hover { opacity: 0.85; }
#end-turn:disabled { opacity: 0.5; cursor: default; }
canvas { border: 2px solid #333; cursor: pointer; display: none; max-width: 100%; height: auto; }
#info-panel {
  display: none;
  margin-top: 10px;
  padding: 10px;
  background: #16213e;
  border-radius: 4px;
  min-height: 40px;
  font-size: 14px;
  line-height: 1.4;
  max-width: 100%;
}
#help-btn, #sound-btn {
  padding: 8px 16px;
  font-size: 14px;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  font-weight: bold;
  background: #555;
  color: #fff;
  transition: opacity 0.2s;
}
#help-btn:hover, #sound-btn:hover { opacity: 0.85; }
#help-panel {
  margin-top: 10px;
  padding: 14px 18px;
  background: #16213e;
  border-radius: 4px;
  font-size: 13px;
  line-height: 1.5;
  display: none;
  max-width: 100%;
  overflow-x: auto;
}
#help-panel table {
  border-collapse: collapse;
  margin: 8px 0;
}
#help-panel th, #help-panel td {
  border: 1px solid #334;
  padding: 4px 10px;
  text-align: center;
}
#help-panel th {
  background: #1a2440;
}
#help-panel h3 {
  margin: 10px 0 4px;
  font-size: 14px;
  color: #8cf;
}
#help-panel h3:first-child { margin-top: 0; }
#start-screen {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 60vh;
  gap: 8px;
}
#start-screen h1 {
  font-size: 36px;
  color: #8cf;
  text-shadow: 0 0 20px rgba(100, 180, 255, 0.3);
  margin-bottom: 4px;
}
#start-screen .subtitle {
  font-size: 16px;
  color: #aaa;
  margin-bottom: 20px;
}
.start-buttons, #team-pick, #hotseat-pick {
  display: flex;
  flex-direction: column;
  gap: 12px;
  align-items: center;
}
.start-buttons button, #team-pick button, #hotseat-pick button {
  padding: 12px 40px;
  font-size: 18px;
  font-weight: bold;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  min-width: 220px;
  transition: opacity 0.2s, transform 0.1s;
}
.start-buttons button:hover, #team-pick button:hover, #hotseat-pick button:hover {
  opacity: 0.85;
  transform: scale(1.03);
}
#btn-vs-ai { background: #4488ff; color: #fff; }
#btn-hotseat { background: #ff8844; color: #fff; }
#btn-about { background: #555; color: #fff; }
#pick-back { background: #555; color: #fff; }
#about-overlay {
  position: fixed;
  inset: 0;
  background: rgba(10, 10, 30, 0.95);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 110;
}
.about-content {
  max-width: 480px;
  padding: 30px;
  background: #16213e;
  border-radius: 8px;
  border: 1px solid #334;
  text-align: center;
  line-height: 1.6;
}
.about-content h2 {
  color: #8cf;
  margin-bottom: 16px;
}
.about-content p {
  margin-bottom: 12px;
  color: #ccc;
}
#about-close {
  margin-top: 16px;
  padding: 10px 30px;
  font-size: 16px;
  background: #555;
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
#about-close:hover { opacity: 0.85; }
.diff-row { display: flex; gap: 10px; }
.diff-btn {
  padding: 8px 24px;
  font-size: 16px;
  font-weight: bold;
  border: 2px solid #555;
  border-radius: 6px;
  cursor: pointer;
  background: #2a2a3e;
  color: #aaa;
  transition: all 0.15s;
}
.diff-btn.active {
  border-color: #8cf;
  color: #fff;
  background: #334;
}
.diff-btn:hover { opacity: 0.85; }
.size-row { display: flex; gap: 10px; }
</style>
</head>
<body>
<div id="start-screen">
  <h1>Fantasy Tactical Battle</h1>
  <p class="subtitle">Hex-based tactical combat</p>
  <div class="start-buttons">
    <button id="btn-vs-ai">Play vs AI</button>
    <button id="btn-hotseat">2P Hotseat</button>
    <button id="btn-about">About</button>
  </div>
  <div id="team-pick" style="display:none;">
    <p>Map Size:</p>
    <div class="size-row">
      <button class="diff-btn size-btn" data-size="small">Small</button>
      <button class="diff-btn size-btn active" data-size="medium">Medium</button>
      <button class="diff-btn size-btn" data-size="large">Large</button>
    </div>
    <p style="margin-top:12px;">Terrain:</p>
    <div class="diff-row">
      <button class="diff-btn density-btn" data-density="light">Light</button>
      <button class="diff-btn density-btn active" data-density="normal">Normal</button>
    </div>
    <p style="margin-top:12px;">Difficulty:</p>
    <div class="diff-row">
      <button class="diff-btn diff-opt active" data-diff="normal">Normal</button>
      <button class="diff-btn diff-opt" data-diff="hard">Hard</button>
    </div>
    <p style="margin-top:16px;">Choose your side:</p>
    <button id="pick-blue" style="background:#4488ff;color:#fff;">Play as Blue (go first)</button>
    <button id="pick-red" style="background:#ff4444;color:#fff;">Play as Red</button>
    <button id="pick-back" style="background:#555;color:#fff;">Back</button>
  </div>
  <div id="hotseat-pick" style="display:none;">
    <p>Map Size:</p>
    <div class="size-row">
      <button class="diff-btn hs-size-btn" data-size="small">Small</button>
      <button class="diff-btn hs-size-btn active" data-size="medium">Medium</button>
      <button class="diff-btn hs-size-btn" data-size="large">Large</button>
    </div>
    <p style="margin-top:12px;">Terrain:</p>
    <div class="diff-row">
      <button class="diff-btn hs-density-btn" data-density="light">Light</button>
      <button class="diff-btn hs-density-btn active" data-density="normal">Normal</button>
    </div>
    <p style="margin-top:16px;"></p>
    <button id="hs-start" style="background:#ff8844;color:#fff;">Start Game</button>
    <button id="hs-back" style="background:#555;color:#fff;">Back</button>
  </div>
</div>
<div id="about-overlay">
  <div class="about-content">
    <h2>About Fantasy Tactical Battle</h2>
    <p>Command your army in hex-based tactical combat. Outmaneuver your opponent
       with swordsmen, spearmen, archers, and cavalry across varied terrain.</p>
    <p>Use terrain for defense bonuses, set up flanking attacks, and exploit
       type advantages to defeat the enemy force.</p>
    <p>Each unit can move and attack once per turn. Combat is deterministic &mdash;
       plan your moves carefully!</p>
    <p style="color:#8cf;">In-game, press <strong>Help</strong> for detailed unit stats,
       damage tables, and terrain modifiers.</p>
    <button id="about-close">Back</button>
  </div>
</div>
<div id="header">
  <span id="turn-info"></span>
  <div>
    <button id="sound-btn" title="Toggle sound">Sound: On</button>
    <button id="help-btn">Help</button>
    <button id="end-turn">End Turn</button>
  </div>
</div>
<canvas id="game"></canvas>
<div id="info-panel">Click a unit to select it.</div>
<div id="help-panel">
  <h3>Units</h3>
  <table>
    <tr><th>Unit</th><th>HP</th><th>Move</th><th>Range</th></tr>
    <tr><td>Swordsman (S)</td><td>110</td><td>3</td><td>1</td></tr>
    <tr><td>Spearman (P)</td><td>100</td><td>3</td><td>1</td></tr>
    <tr><td>Archer (A)</td><td>80</td><td>3</td><td>2</td></tr>
    <tr><td>Cavalry (C)</td><td>100</td><td>4</td><td>1</td></tr>
  </table>
  <h3>Damage (attacker vs defender) — bold = strong matchup</h3>
  <table>
    <tr><th></th><th>vs Sword</th><th>vs Spear</th><th>vs Archer</th><th>vs Cav</th></tr>
    <tr><th>Swordsman</th><td>55</td><td><b>70</b></td><td>55</td><td>55</td></tr>
    <tr><th>Spearman</th><td>55</td><td>55</td><td>55</td><td><b>70</b></td></tr>
    <tr><th>Archer</th><td>55</td><td>55</td><td>55</td><td><b>70</b></td></tr>
    <tr><th>Cavalry</th><td><b>70</b></td><td>55</td><td><b>70</b></td><td>55</td></tr>
  </table>
  <h3>Terrain</h3>
  <table>
    <tr><th>Terrain</th><th>Defense</th><th>Sw cost</th><th>Sp cost</th><th>Arch cost</th><th>Cav cost</th></tr>
    <tr><td>Plains</td><td>+0%</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
    <tr><td>Mountains</td><td>+30%</td><td>3</td><td>3</td><td>3</td><td>—</td></tr>
    <tr><td>Forest</td><td>+30%</td><td>2</td><td>2</td><td>2</td><td>2</td></tr>
    <tr><td>Water</td><td>—</td><td>—</td><td>—</td><td>—</td><td>—</td></tr>
  </table>
  <h3>Flanking (melee only)</h3>
  <table>
    <tr><th>Condition</th><th>Bonus</th></tr>
    <tr><td>1 ally adjacent to defender</td><td>+10% attack</td></tr>
    <tr><td>2+ allies adjacent to defender</td><td>+20% attack</td></tr>
    <tr><td>Ally directly behind defender (backstab)</td><td>+25% attack</td></tr>
  </table>
  <p>Backstab overrides count-based bonuses (no further stacking). Counter-attacks do not receive flanking bonuses.</p>
  <h3>Zone of Control</h3>
  <p>Units exert a zone of control (ZOC) on all 6 adjacent hexes. A unit cannot move directly from one enemy ZOC hex to another &mdash; it must exit ZOC first. This prevents slipping past enemies. Cavalry ignores ZOC from all units except spearmen.</p>
  <h3>Map sizes</h3>
  <p>Small (7&times;7, 5 units/side) for quick skirmishes. Medium (9&times;9, 7 units/side) for strategic depth. Large (9&times;13, 8 units/side) for extended campaigns. Terrain is randomly generated each game with vertical symmetry for fairness.</p>
  <h3>Combat notes</h3>
  <p>Damaged units deal less damage (down to ~50% at very low HP). Defenders counter-attack if the attacker is within their range. Mountains and forests reduce incoming damage by 30%. Water is impassable. Cavalry cannot enter mountains. Units exert ZOC on adjacent hexes (see above). Swordsmen are strong vs spearmen. Spearmen and archers are strong vs cavalry. Cavalry is strong vs swordsmen and archers.</p>
</div>

<script>
// ============================================================
//  DATA DEFINITIONS — Constants that define game rules.
//  Edit these to tune gameplay without touching logic.
// ============================================================

let COLS = 9, ROWS = 9;

const MAP_SIZES = {
  small:  { rows: 7, cols: 7, units: ['cavalry','swordsman','swordsman','spearman','archer'] },
  medium: { rows: 9, cols: 9, units: ['cavalry','swordsman','spearman','archer','archer','swordsman','cavalry'] },
  large:  { rows: 13, cols: 9, units: ['cavalry','swordsman','spearman','archer','archer','spearman','swordsman','cavalry'] },
};

const TERRAIN = { PLAINS: 'plains', MOUNTAINS: 'mountains', FOREST: 'forest', WATER: 'water' };
const TEAM   = { BLUE: 1, RED: 2 };
const PHASE  = { SELECT: 'select', MOVE: 'move', ATTACK: 'attack' };

const TEAM_NAME  = { [TEAM.BLUE]: 'Blue', [TEAM.RED]: 'Red' };
const TEAM_COLOR = { [TEAM.BLUE]: '#4488ff', [TEAM.RED]: '#ff4444' };

const UNIT_DEFS = {
  swordsman: { name: 'Swordsman', hp: 110, move: 3, range: 1 },
  spearman:  { name: 'Spearman',  hp: 100, move: 3, range: 1 },
  archer:    { name: 'Archer',    hp: 80,  move: 3, range: 2 },
  cavalry:   { name: 'Cavalry',   hp: 100, move: 4, range: 1 },
};

const TERRAIN_DEFS = {
  [TERRAIN.PLAINS]:    { name: 'Plains',    defense: 0,  moveCost: { swordsman: 1, spearman: 1, archer: 1, cavalry: 1 } },
  [TERRAIN.MOUNTAINS]: { name: 'Mountains', defense: 30, moveCost: { swordsman: 3, spearman: 3, archer: 3, cavalry: Infinity } },
  [TERRAIN.FOREST]:    { name: 'Forest',    defense: 30, moveCost: { swordsman: 2, spearman: 2, archer: 2, cavalry: 2 } },
  [TERRAIN.WATER]:     { name: 'Water',     defense: 0,  moveCost: { swordsman: Infinity, spearman: Infinity, archer: Infinity, cavalry: Infinity } },
};

// Base damage: DAMAGE_TABLE[attackerType][defenderType]
const DAMAGE_TABLE = {
  swordsman: { swordsman: 55, spearman: 70, archer: 55, cavalry: 55 },
  spearman:  { swordsman: 55, spearman: 55, archer: 55, cavalry: 70 },
  archer:    { swordsman: 55, spearman: 55, archer: 55, cavalry: 70 },
  cavalry:   { swordsman: 70, spearman: 55, archer: 70, cavalry: 55 },
};

// Flanking bonuses (% attack bonus, melee only)
const FLANKING = {
  SUPPORT_1: 10,   // attacker + 1 ally adjacent to defender
  SUPPORT_2: 20,   // attacker + 2+ allies adjacent to defender
  BACKSTAB:  25,   // ally directly behind defender (no further stacking)
};

// ============================================================
//  HEX GRID — Pointy-top hexes, odd-r offset coordinates.
//  Odd rows are shifted right by half a hex width.
// ============================================================

const HEX_SIZE = 34;                        // center to vertex
const SQRT3   = Math.sqrt(3);
const HEX_W   = SQRT3 * HEX_SIZE;           // hex width (flat-to-flat)
const HEX_H   = 2 * HEX_SIZE;               // hex height (point-to-point)

// 6 neighbor offsets, indexed by row parity: [even-row, odd-row]
const HEX_DIRS = [
  [[-1,-1], [-1, 0], [0,-1], [0, 1], [1,-1], [1, 0]],   // even rows
  [[-1, 0], [-1, 1], [0,-1], [0, 1], [1, 0], [1, 1]],   // odd rows
];

/** Returns in-bounds hex neighbors for a cell at (row, col). */
function hexNeighbors(row, col) {
  const dirs = HEX_DIRS[row & 1];
  const result = [];
  for (const [dr, dc] of dirs) {
    const nr = row + dr, nc = col + dc;
    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) result.push({ row: nr, col: nc });
  }
  return result;
}

/** Convert offset (row, col) to pixel center of the hex. */
function hexToPixel(row, col) {
  return {
    x: HEX_W * (col + 0.5 * (row & 1)) + HEX_W / 2,
    y: HEX_SIZE * 1.5 * row + HEX_SIZE,
  };
}

/** Convert pixel position to offset (row, col) via axial rounding. */
function pixelToHex(px, py) {
  // Undo the origin offset to get coords relative to hex (0,0) center
  const x = px - HEX_W / 2;
  const y = py - HEX_SIZE;
  // Pixel to fractional axial (pointy-top)
  const q = (SQRT3 / 3 * x - y / 3) / HEX_SIZE;
  const r = (2 / 3 * y) / HEX_SIZE;
  // Cube round
  const s = -q - r;
  let rq = Math.round(q), rr = Math.round(r), rs = Math.round(s);
  const dq = Math.abs(rq - q), dr = Math.abs(rr - r), ds = Math.abs(rs - s);
  if (dq > dr && dq > ds) rq = -rr - rs;
  else if (dr > ds)        rr = -rq - rs;
  // Axial to offset (odd-r)
  const col = rq + (rr - (rr & 1)) / 2;
  const row = rr;
  if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return null;
  return { row, col };
}

/** Hex distance between two offset cells (via cube coordinates). */
function hexDistance(r1, c1, r2, c2) {
  const x1 = c1 - (r1 - (r1 & 1)) / 2, z1 = r1, y1 = -x1 - z1;
  const x2 = c2 - (r2 - (r2 & 1)) / 2, z2 = r2, y2 = -x2 - z2;
  return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2), Math.abs(z1 - z2));
}

// Canvas dimensions to fit the hex grid exactly (recalculated per game)
let CANVAS_W = Math.ceil(HEX_W * (COLS + 0.5));
let CANVAS_H = Math.ceil(HEX_SIZE * (1.5 * ROWS + 0.5));

function recalcCanvasDims() {
  CANVAS_W = Math.ceil(HEX_W * (COLS + 0.5));
  CANVAS_H = Math.ceil(HEX_SIZE * (1.5 * ROWS + 0.5));
}

// ============================================================
//  MAP & UNIT GENERATION — Procedural, symmetric, balanced.
// ============================================================

/** Generate a random terrain map with vertical symmetry for fairness. */
const TERRAIN_DENSITY = {
  normal: { mountain: 0.10, forest: 0.14, water: 0.04, midRow: 0.25 },
  light:  { mountain: 0.05, forest: 0.07, water: 0.02, midRow: 0.12 },
};

function generateMap(rows, cols, density) {
  const P = TERRAIN.PLAINS, M = TERRAIN.MOUNTAINS, F = TERRAIN.FOREST, W = TERRAIN.WATER;
  // Start with all plains
  const map = Array.from({ length: rows }, () => Array(cols).fill(P));

  const midRow = Math.floor(rows / 2);
  const innerCells = (midRow - 1) * cols; // cells in the top half (excluding spawn row)

  // Terrain budgets (approximate cell counts for the top half; mirrored to bottom)
  const d = TERRAIN_DENSITY[density] || TERRAIN_DENSITY.normal;
  const mtnCount = Math.max(1, Math.round(innerCells * d.mountain));
  const forestCount = Math.max(1, Math.round(innerCells * d.forest));
  const waterCount = Math.max(0, Math.round(innerCells * d.water));

  // Collect eligible cells for placement (rows 1 through midRow-1 = top half, excluding spawn)
  const topCells = [];
  for (let r = 1; r < midRow; r++) {
    for (let c = 0; c < cols; c++) {
      topCells.push({ r, c });
    }
  }
  // Shuffle
  for (let i = topCells.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [topCells[i], topCells[j]] = [topCells[j], topCells[i]];
  }

  // Place terrain from the shuffled pool, mirroring to the bottom half
  let placed = 0;
  const placeType = (type, count) => {
    let n = 0;
    while (n < count && placed < topCells.length) {
      const { r, c } = topCells[placed++];
      if (map[r][c] !== P) continue; // skip if already claimed
      map[r][c] = type;
      map[rows - 1 - r][c] = type; // mirror
      n++;
    }
  };

  placeType(M, mtnCount);
  placeType(F, forestCount);
  // Water restricted to rows 2..(rows-3) to avoid blocking near spawns
  const waterCells = [];
  for (let i = placed; i < topCells.length; i++) {
    if (topCells[i].r >= 2) waterCells.push(topCells[i]);
  }
  for (let i = waterCells.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [waterCells[i], waterCells[j]] = [waterCells[j], waterCells[i]];
  }
  let wn = 0;
  for (const { r, c } of waterCells) {
    if (wn >= waterCount) break;
    if (map[r][c] !== P) continue;
    map[r][c] = W;
    map[rows - 1 - r][c] = W;
    wn++;
  }

  // Middle row (odd-row grids): scatter some terrain independently
  if (rows % 2 === 1) {
    const mr = midRow;
    const midBudget = Math.max(1, Math.round(cols * d.midRow));
    const midIndices = Array.from({ length: cols }, (_, i) => i);
    for (let i = midIndices.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [midIndices[i], midIndices[j]] = [midIndices[j], midIndices[i]];
    }
    let mp = 0;
    for (const c of midIndices) {
      if (mp >= midBudget) break;
      const pick = Math.random();
      if (pick < 0.4) { map[mr][c] = F; mp++; }
      else if (pick < 0.6) { map[mr][c] = M; mp++; }
      else if (pick < 0.7) { map[mr][c] = W; mp++; }
    }
  }

  // Connectivity check: BFS from any top-row cell to any bottom-row cell
  // using infantry movement (worst-case excluding cavalry which can't do mountains)
  if (!mapIsConnected(map, rows, cols)) return generateMap(rows, cols, density);

  return map;
}

/** BFS connectivity check: can infantry reach from row 0 to row (rows-1)? */
function mapIsConnected(map, rows, cols) {
  const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
  const queue = [];
  // Seed from all traversable cells in row 0
  for (let c = 0; c < cols; c++) {
    const t = map[0][c];
    if (TERRAIN_DEFS[t].moveCost.swordsman < Infinity) {
      visited[0][c] = true;
      queue.push([0, c]);
    }
  }
  let head = 0;
  while (head < queue.length) {
    const [r, c] = queue[head++];
    if (r === rows - 1) return true;
    const dirs = HEX_DIRS[r & 1];
    for (const [dr, dc] of dirs) {
      const nr = r + dr, nc = c + dc;
      if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;
      if (visited[nr][nc]) continue;
      if (TERRAIN_DEFS[map[nr][nc]].moveCost.swordsman >= Infinity) continue;
      visited[nr][nc] = true;
      queue.push([nr, nc]);
    }
  }
  return false;
}

/** Build unit arrays for both teams given a MAP_SIZES preset. */
function generateUnits(preset, rows, cols) {
  const types = preset.units;
  const count = types.length;
  // Spread units across home row, centered
  const startCol = Math.floor((cols - count) / 2);
  const units = [];
  for (let i = 0; i < count; i++) {
    const c = startCol + i;
    units.push({ type: types[i], team: TEAM.BLUE, row: rows - 1, col: c });
    units.push({ type: types[i], team: TEAM.RED,  row: 0,        col: c });
  }
  return units;
}

// ============================================================
//  GAME STATE — Pure data container, fully serializable.
//  No methods with side effects. No DOM references.
// ============================================================

class GameState {
  constructor() {
    this.map = [];               // 2D array of TERRAIN values
    this.units = [];             // Array of unit objects
    this.currentTeam = TEAM.BLUE;
    this.turnNumber = 1;
    this.phase = PHASE.SELECT;
    this.selectedUnitId = null;
    this.highlightedMoves = [];  // [{row, col}]
    this.highlightedAttacks = []; // [unitId]
    this.winner = null;
  }

  static createInitial(mapData, unitData) {
    const s = new GameState();
    s.map = mapData;
    s.units = unitData.map((u, i) => ({
      id: i, type: u.type, team: u.team,
      row: u.row, col: u.col,
      hp: UNIT_DEFS[u.type].hp, moved: false, attacked: false,
    }));
    return s;
  }

  getUnit(id)        { return this.units.find(u => u.id === id); }
  getUnitAt(row, col) { return this.units.find(u => u.row === row && u.col === col && u.hp > 0); }
  getLivingUnits(team) { return this.units.filter(u => u.team === team && u.hp > 0); }

  serialize()              { return JSON.parse(JSON.stringify(this)); }
  static deserialize(json) { return Object.assign(new GameState(), JSON.parse(JSON.stringify(json))); }
}

// ============================================================
//  GAME RULES — Pure functions operating on GameState.
//  No side effects, no DOM, no rendering. Fully testable.
// ============================================================

class GameRules {

  /** Is (row,col) in an enemy's zone of control relevant to the moving unit?
   *  Cavalry only affected by spearman ZOC; all other units affected by any enemy. */
  static isInZOC(state, row, col, movingUnit) {
    for (const nb of hexNeighbors(row, col)) {
      const u = state.getUnitAt(nb.row, nb.col);
      if (!u || u.hp <= 0 || u.team === movingUnit.team) continue;
      if (movingUnit.type === 'cavalry' && u.type !== 'spearman') continue;
      return true;
    }
    return false;
  }

  /** Returns all cells a unit can move to, respecting terrain, occupancy, and ZOC.
   *  If parentMap (a Map) is provided, it is populated with parent pointers for path reconstruction. */
  static getMovableCells(state, unit, parentMap) {
    const maxMove = UNIT_DEFS[unit.type].move;
    const visited = new Map();
    const startKey = `${unit.row},${unit.col}`;
    const queue = [{ row: unit.row, col: unit.col, remaining: maxMove }];
    visited.set(startKey, maxMove);
    if (parentMap) parentMap.set(startKey, null);

    while (queue.length > 0) {
      const { row, col, remaining } = queue.shift();
      for (const nb of hexNeighbors(row, col)) {
        const cost = TERRAIN_DEFS[state.map[nb.row][nb.col]].moveCost[unit.type];
        if (cost === Infinity) continue;
        const rem = remaining - cost;
        if (rem < 0) continue;
        const key = `${nb.row},${nb.col}`;
        if (visited.has(key) && visited.get(key) >= rem) continue;
        const occ = state.getUnitAt(nb.row, nb.col);
        if (occ && occ.team !== unit.team) continue;
        // ZOC: can't move from one enemy ZOC hex to another (except leaving start)
        if (!(row === unit.row && col === unit.col) &&
            GameRules.isInZOC(state, row, col, unit) &&
            GameRules.isInZOC(state, nb.row, nb.col, unit)) continue;
        visited.set(key, rem);
        if (parentMap) parentMap.set(key, `${row},${col}`);
        queue.push({ row: nb.row, col: nb.col, remaining: rem });
      }
    }

    const cells = [];
    for (const [key] of visited) {
      const [r, c] = key.split(',').map(Number);
      const occ = state.getUnitAt(r, c);
      if (occ && occ.id !== unit.id) continue;
      cells.push({ row: r, col: c });
    }
    return cells;
  }

  /** Reconstruct the path from a parentMap (built by getMovableCells) to a target cell. */
  static reconstructPath(parentMap, targetRow, targetCol) {
    const path = [];
    let key = `${targetRow},${targetCol}`;
    while (key && parentMap.has(key)) {
      const [r, c] = key.split(',').map(Number);
      path.unshift({ row: r, col: c });
      key = parentMap.get(key);
    }
    return path;
  }

  /** Returns enemy units within attack range. */
  static getAttackTargets(state, unit) {
    const range = UNIT_DEFS[unit.type].range;
    const targets = [];
    for (const other of state.units) {
      if (other.hp <= 0 || other.team === unit.team) continue;
      if (hexDistance(unit.row, unit.col, other.row, other.col) <= range) {
        targets.push(other);
      }
    }
    return targets;
  }

  /** Calculate flanking attack bonus (melee only). */
  static getFlankingBonus(state, attacker, defender) {
    if (hexDistance(attacker.row, attacker.col, defender.row, defender.col) > 1) return 0;

    const dirs = HEX_DIRS[defender.row & 1];

    // Find which direction the attacker is relative to the defender
    let attackerDirIdx = -1;
    for (let i = 0; i < 6; i++) {
      if (defender.row + dirs[i][0] === attacker.row &&
          defender.col + dirs[i][1] === attacker.col) {
        attackerDirIdx = i;
        break;
      }
    }
    if (attackerDirIdx === -1) return 0;

    // Check backstab: ally directly behind defender (opposite hex)
    const oppIdx = (attackerDirIdx + 3) % 6;
    const oppR = defender.row + dirs[oppIdx][0];
    const oppC = defender.col + dirs[oppIdx][1];
    if (oppR >= 0 && oppR < ROWS && oppC >= 0 && oppC < COLS) {
      const oppUnit = state.getUnitAt(oppR, oppC);
      if (oppUnit && oppUnit.team === attacker.team) {
        return FLANKING.BACKSTAB;
      }
    }

    // Count allies adjacent to defender (excluding attacker)
    let adjacentAllies = 0;
    for (let i = 0; i < 6; i++) {
      if (i === attackerDirIdx) continue;
      const nr = defender.row + dirs[i][0];
      const nc = defender.col + dirs[i][1];
      if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) continue;
      const u = state.getUnitAt(nr, nc);
      if (u && u.team === attacker.team) adjacentAllies++;
    }

    if (adjacentAllies >= 2) return FLANKING.SUPPORT_2;
    if (adjacentAllies >= 1) return FLANKING.SUPPORT_1;
    return 0;
  }

  static calculateDamage(attackerType, attackerHp, defenderType, defenderTerrain) {
    const base = DAMAGE_TABLE[attackerType][defenderType];
    const atkMod = 0.5 + 0.5 * (attackerHp / 100);
    const defBonus = TERRAIN_DEFS[defenderTerrain].defense;
    return Math.max(1, Math.round(base * atkMod * (100 - defBonus) / 100));
  }

  static resolveAttack(state, attackerId, defenderId) {
    const atk = state.getUnit(attackerId);
    const def = state.getUnit(defenderId);
    const defTerrain = state.map[def.row][def.col];
    const atkTerrain = state.map[atk.row][atk.col];

    const baseDamage = this.calculateDamage(atk.type, atk.hp, def.type, defTerrain);
    const flankBonus = this.getFlankingBonus(state, atk, def);
    const damage = flankBonus > 0 ? Math.max(1, Math.round(baseDamage * (100 + flankBonus) / 100)) : baseDamage;
    def.hp = Math.max(0, def.hp - damage);

    let counterDamage = 0;
    const dist = hexDistance(atk.row, atk.col, def.row, def.col);
    if (def.hp > 0 && dist <= UNIT_DEFS[def.type].range) {
      counterDamage = this.calculateDamage(def.type, def.hp, atk.type, atkTerrain);
      atk.hp = Math.max(0, atk.hp - counterDamage);
    }

    return {
      damage, counterDamage, flankBonus,
      defenderDestroyed: def.hp <= 0,
      attackerDestroyed: atk.hp <= 0,
    };
  }

  static moveUnit(state, unitId, toRow, toCol) {
    const unit = state.getUnit(unitId);
    unit.row = toRow;
    unit.col = toCol;
  }

  static endTurn(state) {
    for (const u of state.getLivingUnits(state.currentTeam)) { u.moved = false; u.attacked = false; }
    state.currentTeam = state.currentTeam === TEAM.BLUE ? TEAM.RED : TEAM.BLUE;
    if (state.currentTeam === TEAM.BLUE) state.turnNumber++;
    state.phase = PHASE.SELECT;
    state.selectedUnitId = null;
    state.highlightedMoves = [];
    state.highlightedAttacks = [];
  }

  static checkWinner(state) {
    if (state.getLivingUnits(TEAM.BLUE).length === 0) return TEAM.RED;
    if (state.getLivingUnits(TEAM.RED).length === 0) return TEAM.BLUE;
    return null;
  }
}

// ============================================================
//  AI PLAYER — Greedy positional AI. No DOM, no side effects.
//  Reads GameState via GameRules to plan a full turn, returns
//  an ordered list of actions for GameController to execute.
// ============================================================

class AIPlayer {
  constructor(team, difficulty = 'normal') {
    this.team = team;
    this.difficulty = difficulty;
  }

  /** Plan the entire turn. Returns array of actions. */
  planTurn(state) {
    const sim = GameState.deserialize(state.serialize());
    const actions = [];
    const myUnits = sim.getLivingUnits(this.team);
    const ordered = this.prioritizeUnits(sim, myUnits);

    // Hard mode: pre-compute tactical context
    let context = null;
    if (this.difficulty === 'hard') {
      context = {
        dangerMap: this.buildDangerMap(sim),
        focusTargets: this.identifyFocusTargets(sim),
      };
    }

    for (const unit of ordered) {
      if (unit.hp <= 0) continue;
      const action = this.planUnitAction(sim, unit, context);
      actions.push(action);
      this.applyAction(sim, action);
    }
    return actions;
  }

  /** Hard mode: build a map of which hexes each enemy can reach and attack next turn. */
  buildDangerMap(state) {
    const map = new Map();
    const enemyTeam = this.team === TEAM.BLUE ? TEAM.RED : TEAM.BLUE;
    const enemies = state.getLivingUnits(enemyTeam);

    for (const enemy of enemies) {
      const reachable = GameRules.getMovableCells(state, enemy);
      const threatened = new Set();
      const range = UNIT_DEFS[enemy.type].range;

      for (const cell of reachable) {
        for (let r = Math.max(0, cell.row - range - 1); r <= Math.min(ROWS - 1, cell.row + range + 1); r++) {
          for (let c = Math.max(0, cell.col - range - 1); c <= Math.min(COLS - 1, cell.col + range + 1); c++) {
            if (hexDistance(cell.row, cell.col, r, c) <= range) {
              threatened.add(`${r},${c}`);
            }
          }
        }
      }

      for (const key of threatened) {
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(enemy);
      }
    }
    return map;
  }

  /** Hard mode: identify high-priority targets for coordinated focus fire. */
  identifyFocusTargets(state) {
    const enemyTeam = this.team === TEAM.BLUE ? TEAM.RED : TEAM.BLUE;
    const enemies = state.getLivingUnits(enemyTeam);
    const myUnits = state.getLivingUnits(this.team);

    // Cache movable cells per unit
    const moveCache = new Map();
    for (const unit of myUnits) {
      moveCache.set(unit.id, GameRules.getMovableCells(state, unit));
    }

    const analysis = enemies.map(enemy => {
      let potentialDmg = 0;
      let reachCount = 0;

      for (const unit of myUnits) {
        const moveCells = moveCache.get(unit.id);
        const range = UNIT_DEFS[unit.type].range;
        let canAttack = false;

        for (const cell of moveCells) {
          if (hexDistance(cell.row, cell.col, enemy.row, enemy.col) <= range) {
            canAttack = true;
            break;
          }
        }

        if (canAttack) {
          reachCount++;
          potentialDmg += GameRules.calculateDamage(unit.type, unit.hp, enemy.type, state.map[enemy.row][enemy.col]);
        }
      }

      return {
        id: enemy.id,
        hp: enemy.hp,
        type: enemy.type,
        potentialDmg,
        reachCount,
        canKill: potentialDmg >= enemy.hp,
      };
    });

    // Killable targets first, then wounded, then high-value
    analysis.sort((a, b) => {
      if (a.canKill !== b.canKill) return b.canKill - a.canKill;
      if (a.canKill && b.canKill) return a.reachCount - b.reachCount;
      return a.hp - b.hp;
    });

    return analysis.slice(0, 2).map(a => a.id);
  }

  /** Determine unit execution order for maximum effectiveness. */
  prioritizeUnits(state, units) {
    const enemyTeam = this.team === TEAM.BLUE ? TEAM.RED : TEAM.BLUE;
    const enemies = state.getLivingUnits(enemyTeam);

    const scored = units.map(unit => {
      let priority = 0;

      // Units that can secure a kill go first
      const targets = GameRules.getAttackTargets(state, unit);
      for (const target of targets) {
        const damage = GameRules.calculateDamage(unit.type, unit.hp, target.type,
                         state.map[target.row][target.col]);
        const flank = GameRules.getFlankingBonus(state, unit, target);
        const finalDmg = flank > 0 ? Math.max(1, Math.round(damage * (100 + flank) / 100)) : damage;
        if (finalDmg >= target.hp) priority += 500;
      }

      // Ranged units go before melee (no counter = pure value)
      if (UNIT_DEFS[unit.type].range > 1) priority += 100;

      // Units adjacent to enemies go before distant ones
      let minDist = Infinity;
      for (const enemy of enemies) {
        const d = hexDistance(unit.row, unit.col, enemy.row, enemy.col);
        if (d < minDist) minDist = d;
      }
      if (minDist <= 1) priority += 80;
      else if (minDist <= 2) priority += 40;

      // Units with strong matchups nearby go earlier
      for (const enemy of enemies) {
        const d = hexDistance(unit.row, unit.col, enemy.row, enemy.col);
        if (d <= UNIT_DEFS[unit.type].move + UNIT_DEFS[unit.type].range) {
          if (DAMAGE_TABLE[unit.type][enemy.type] >= 70) priority += 30;
        }
      }

      // Wounded units go last (may want to retreat after allies clear threats)
      if (unit.hp <= 40) priority -= 50;

      return { unit, priority };
    });

    scored.sort((a, b) => b.priority - a.priority);
    return scored.map(s => s.unit);
  }

  /** Find the best action for a single unit. */
  planUnitAction(state, unit, context) {
    let bestAction = { unitId: unit.id, move: null, attackTargetId: null, attackBeforeMove: false };
    let bestScore = -Infinity;

    const candidates = this.generateCandidateActions(state, unit);
    for (const candidate of candidates) {
      const score = this.evaluateAction(state, unit, candidate, context);
      if (score > bestScore) {
        bestScore = score;
        bestAction = candidate;
      }
    }
    return bestAction;
  }

  /** Enumerate all legal action combinations for one unit. */
  generateCandidateActions(state, unit) {
    const candidates = [];

    // Option A: Attack before move (fire from current position, then move)
    if (!unit.attacked) {
      const preTargets = GameRules.getAttackTargets(state, unit);
      for (const target of preTargets) {
        // Attack then stay
        candidates.push({
          unitId: unit.id, move: null,
          attackTargetId: target.id, attackBeforeMove: true
        });

        // Attack then move somewhere
        if (!unit.moved) {
          const simState = GameState.deserialize(state.serialize());
          GameRules.resolveAttack(simState, unit.id, target.id);
          const simUnit = simState.getUnit(unit.id);
          if (simUnit.hp > 0) {
            const moveCells = GameRules.getMovableCells(simState, simUnit);
            for (const cell of moveCells) {
              if (cell.row === unit.row && cell.col === unit.col) continue;
              candidates.push({
                unitId: unit.id, move: cell,
                attackTargetId: target.id, attackBeforeMove: true
              });
            }
          }
        }
      }
    }

    // Option B: Move then attack (or just move)
    if (!unit.moved) {
      const moveCells = GameRules.getMovableCells(state, unit);
      for (const cell of moveCells) {
        const isStay = (cell.row === unit.row && cell.col === unit.col);

        if (!unit.attacked) {
          // Simulate unit at new position, find attack targets
          const simState = GameState.deserialize(state.serialize());
          GameRules.moveUnit(simState, unit.id, cell.row, cell.col);
          const simUnit = simState.getUnit(unit.id);
          const postTargets = GameRules.getAttackTargets(simState, simUnit);

          for (const target of postTargets) {
            candidates.push({
              unitId: unit.id,
              move: isStay ? null : cell,
              attackTargetId: target.id,
              attackBeforeMove: false
            });
          }
        }

        // Move only (no attack)
        if (!isStay) {
          candidates.push({
            unitId: unit.id, move: cell,
            attackTargetId: null, attackBeforeMove: false
          });
        }
      }
    }

    // Option C: Do nothing
    candidates.push({
      unitId: unit.id, move: null, attackTargetId: null, attackBeforeMove: false
    });

    return candidates;
  }

  /** Score an action. Higher = better. */
  evaluateAction(state, unit, action, context) {
    const sim = GameState.deserialize(state.serialize());
    const simUnit = sim.getUnit(unit.id);
    let score = 0;

    // Execute the action in simulation
    let combatResult = null;
    if (action.attackBeforeMove && action.attackTargetId !== null) {
      combatResult = GameRules.resolveAttack(sim, unit.id, action.attackTargetId);
    }
    if (action.move) {
      GameRules.moveUnit(sim, unit.id, action.move.row, action.move.col);
    }
    if (!action.attackBeforeMove && action.attackTargetId !== null) {
      combatResult = GameRules.resolveAttack(sim, unit.id, action.attackTargetId);
    }

    // ----- COMBAT SCORING -----
    if (combatResult) {
      const target = state.getUnit(action.attackTargetId);

      // Raw damage dealt
      score += combatResult.damage * 2;

      // Kill bonus — removing a unit is extremely valuable
      if (combatResult.defenderDestroyed) {
        score += 300;
        if (target.type === 'cavalry') score += 50;
        if (target.type === 'archer') score += 40;
      }

      // Focus fire — prefer attacking already-wounded units
      if (target.hp < 100) {
        score += (100 - target.hp) * 1.5;
      }

      // Favorable matchup bonus
      if (DAMAGE_TABLE[unit.type][target.type] >= 70) score += 30;

      // Counter-attack penalty
      score -= combatResult.counterDamage * 1.5;

      // Self-destruction penalty
      if (combatResult.attackerDestroyed) score -= 350;

      // Net HP trade bonus
      score += (combatResult.damage - combatResult.counterDamage) * 0.5;

      // Hard mode: coordinated focus fire bonus
      if (context && context.focusTargets.includes(action.attackTargetId)) {
        score += 100;
      }
    }

    // ----- POSITIONAL SCORING -----
    const finalRow = action.move ? action.move.row : unit.row;
    const finalCol = action.move ? action.move.col : unit.col;
    const terrain = state.map[finalRow][finalCol];
    const terrainDef = TERRAIN_DEFS[terrain].defense;
    const enemyTeam = this.team === TEAM.BLUE ? TEAM.RED : TEAM.BLUE;
    const enemies = sim.getLivingUnits(enemyTeam);

    // ----- THREAT ASSESSMENT -----
    if (context) {
      // Hard mode: precise danger map
      const dangerKey = `${finalRow},${finalCol}`;
      const threats = context.dangerMap.get(dangerKey) || [];

      // Terrain bonus scales with whether we're actually threatened
      // No point camping a mountain nobody's attacking
      score += terrainDef * (threats.length > 0 ? 1.5 : 0.3);

      if (threats.length > 0) {
        // Calculate actual incoming damage potential
        let totalIncomingDmg = 0;
        for (const enemy of threats) {
          totalIncomingDmg += GameRules.calculateDamage(enemy.type, enemy.hp, unit.type, terrain);
        }

        score -= threats.length * 20;

        // Can we be killed next turn? Huge penalty
        if (simUnit.hp > 0 && totalIncomingDmg >= simUnit.hp) {
          score -= 250;
        }

        // Wounded and exposed — scale penalty with actual danger
        if (simUnit.hp > 0 && simUnit.hp <= 50) {
          score -= totalIncomingDmg * 0.5;
        }

        // Archer safety — archers heavily penalized in threatened hexes
        if (unit.type === 'archer') {
          score -= threats.length * 25;
        }
      }
    } else {
      // Normal mode: terrain bonus + rough threat assessment
      score += terrainDef * 1.5;
      let threatsToUs = 0;
      for (const enemy of enemies) {
        const dist = hexDistance(finalRow, finalCol, enemy.row, enemy.col);
        const enemyReach = UNIT_DEFS[enemy.type].move + UNIT_DEFS[enemy.type].range;
        if (dist <= enemyReach) {
          threatsToUs++;
          if (simUnit.hp > 0 && simUnit.hp <= 40) score -= 40;
        }
      }
      score -= threatsToUs * 15;
    }

    // Wounded unit retreat
    if (simUnit.hp > 0 && simUnit.hp <= (context ? 50 : 40)) {
      let minEnemyDist = Infinity;
      for (const enemy of enemies) {
        const d = hexDistance(finalRow, finalCol, enemy.row, enemy.col);
        if (d < minEnemyDist) minEnemyDist = d;
      }
      score += minEnemyDist * (context ? 10 : 8);
      score += terrainDef * 2;
    }

    // Advance toward enemies when healthy and no attack
    if (!combatResult && simUnit.hp > 60) {
      let minEnemyDist = Infinity;
      for (const enemy of enemies) {
        const d = hexDistance(finalRow, finalCol, enemy.row, enemy.col);
        if (d < minEnemyDist) minEnemyDist = d;
      }
      score -= minEnemyDist * (context ? 5 : 3);
    }

    // Hard mode: frontline support — don't leave allies to fight alone
    if (context && !combatResult && simUnit.hp > 50) {
      const allies = sim.getLivingUnits(this.team).filter(u => u.id !== unit.id);
      let minDistToFrontline = Infinity;
      let hasFrontline = false;
      for (const ally of allies) {
        for (const enemy of enemies) {
          if (hexDistance(ally.row, ally.col, enemy.row, enemy.col) <= 3) {
            hasFrontline = true;
            const d = hexDistance(finalRow, finalCol, ally.row, ally.col);
            if (d < minDistToFrontline) minDistToFrontline = d;
            break;
          }
        }
      }
      if (hasFrontline && minDistToFrontline > 2) {
        score -= minDistToFrontline * 8;
      }
    }

    // Flanking setup (melee units positioning near enemies)
    if (!combatResult && UNIT_DEFS[unit.type].range === 1) {
      for (const enemy of enemies) {
        const dist = hexDistance(finalRow, finalCol, enemy.row, enemy.col);
        if (dist === 1) {
          // Adjacent to enemy — check if we enable flanking for allies
          const allyNeighbors = hexNeighbors(enemy.row, enemy.col).filter(nb => {
            const u = sim.getUnitAt(nb.row, nb.col);
            return u && u.team === this.team && u.id !== unit.id;
          });
          if (allyNeighbors.length > 0) score += 25;

          // Check backstab position
          const dirs = HEX_DIRS[enemy.row & 1];
          for (const ally of allyNeighbors) {
            let allyDirIdx = -1;
            for (let i = 0; i < 6; i++) {
              if (enemy.row + dirs[i][0] === ally.row &&
                  enemy.col + dirs[i][1] === ally.col) {
                allyDirIdx = i;
                break;
              }
            }
            if (allyDirIdx !== -1) {
              const oppIdx = (allyDirIdx + 3) % 6;
              const oppR = enemy.row + dirs[oppIdx][0];
              const oppC = enemy.col + dirs[oppIdx][1];
              if (oppR === finalRow && oppC === finalCol) score += 35;
            }
          }
        }
      }
    }

    // Archer positioning — prefer range 2 (no counter)
    if (unit.type === 'archer' && !combatResult) {
      for (const enemy of enemies) {
        const dist = hexDistance(finalRow, finalCol, enemy.row, enemy.col);
        if (dist === 2) score += 15;
        if (dist === 1) score -= (context ? 30 : 10);
      }
    }

    return score;
  }

  /** Apply an action to a simulation state. */
  applyAction(state, action) {
    const unit = state.getUnit(action.unitId);
    if (!unit || unit.hp <= 0) return;
    if (action.attackBeforeMove && action.attackTargetId !== null) {
      const target = state.getUnit(action.attackTargetId);
      if (target && target.hp > 0) {
        GameRules.resolveAttack(state, action.unitId, action.attackTargetId);
        unit.attacked = true;
      }
    }
    if (action.move && unit.hp > 0) {
      GameRules.moveUnit(state, action.unitId, action.move.row, action.move.col);
      unit.moved = true;
    }
    if (!action.attackBeforeMove && action.attackTargetId !== null && unit.hp > 0) {
      const target = state.getUnit(action.attackTargetId);
      if (target && target.hp > 0) {
        GameRules.resolveAttack(state, action.unitId, action.attackTargetId);
        unit.attacked = true;
      }
    }
  }
}

// ============================================================
//  RENDERER — Canvas hex renderer. Swap this class to change
//  rendering tech (Canvas → WebGL, DOM, terminal, etc.)
// ============================================================

class CanvasRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    canvas.width = CANVAS_W;
    canvas.height = CANVAS_H;
  }

  /** Trace a pointy-top hex path centered at (cx, cy). */
  hexPath(cx, cy, size) {
    const ctx = this.ctx;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
      const angle = Math.PI / 3 * i - Math.PI / 2;
      const vx = cx + size * Math.cos(angle);
      const vy = cy + size * Math.sin(angle);
      if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
    }
    ctx.closePath();
  }

  render(state, hoverCell, tooltipData, hoverPath) {
    const ctx = this.ctx;
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // Background fill (visible in gaps if any)
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

    const moveSet = new Set(state.highlightedMoves.map(c => `${c.row},${c.col}`));
    const attackSet = new Set(state.highlightedAttacks);

    // -- Terrain hexes --
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const { x: cx, y: cy } = hexToPixel(r, c);
        const terrain = state.map[r][c];

        // Base terrain fill (slightly oversized to avoid seams)
        this.hexPath(cx, cy, HEX_SIZE + 0.5);
        if (terrain === TERRAIN.MOUNTAINS) {
          ctx.fillStyle = '#7a6548';
        } else if (terrain === TERRAIN.FOREST) {
          ctx.fillStyle = (r + c) % 2 === 0 ? '#3a7a30' : '#2e6828';
        } else if (terrain === TERRAIN.WATER) {
          ctx.fillStyle = (r + c) % 2 === 0 ? '#2266aa' : '#1d5a96';
        } else {
          ctx.fillStyle = (r + c) % 2 === 0 ? '#7ec850' : '#6ab040';
        }
        ctx.fill();

        // Terrain decorations
        if (terrain === TERRAIN.MOUNTAINS) {
          const s = HEX_SIZE * 0.55;
          ctx.fillStyle = '#9a8060';
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.7, cy + s * 0.6);
          ctx.lineTo(cx,           cy - s * 0.7);
          ctx.lineTo(cx + s * 0.7, cy + s * 0.6);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#d4c8b0';
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.22, cy - s * 0.3);
          ctx.lineTo(cx,            cy - s * 0.7);
          ctx.lineTo(cx + s * 0.22, cy - s * 0.3);
          ctx.closePath();
          ctx.fill();
        } else if (terrain === TERRAIN.FOREST) {
          const s = HEX_SIZE * 0.35;
          // Left tree
          ctx.fillStyle = '#2a5a20';
          ctx.beginPath();
          ctx.moveTo(cx - s * 1.2, cy + s * 0.7);
          ctx.lineTo(cx - s * 0.5, cy - s * 0.8);
          ctx.lineTo(cx + s * 0.2, cy + s * 0.7);
          ctx.closePath();
          ctx.fill();
          // Right tree
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy + s * 0.7);
          ctx.lineTo(cx + s * 0.6, cy - s * 1.0);
          ctx.lineTo(cx + s * 1.3, cy + s * 0.7);
          ctx.closePath();
          ctx.fill();
        } else if (terrain === TERRAIN.WATER) {
          // Wave lines
          ctx.strokeStyle = 'rgba(100, 180, 255, 0.4)';
          ctx.lineWidth = 1.5;
          const w = HEX_SIZE * 0.4;
          for (let wy = -1; wy <= 1; wy++) {
            ctx.beginPath();
            ctx.moveTo(cx - w, cy + wy * 8);
            ctx.quadraticCurveTo(cx - w * 0.5, cy + wy * 8 - 4, cx, cy + wy * 8);
            ctx.quadraticCurveTo(cx + w * 0.5, cy + wy * 8 + 4, cx + w, cy + wy * 8);
            ctx.stroke();
          }
          ctx.lineWidth = 1;
        }

        // Movement highlight
        if (moveSet.has(`${r},${c}`)) {
          this.hexPath(cx, cy, HEX_SIZE);
          ctx.fillStyle = 'rgba(100, 180, 255, 0.35)';
          ctx.fill();
        }

        // Hover highlight
        if (hoverCell && hoverCell.row === r && hoverCell.col === c) {
          this.hexPath(cx, cy, HEX_SIZE);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.12)';
          ctx.fill();
        }

        // Hex outline
        this.hexPath(cx, cy, HEX_SIZE);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }

    // -- Movement path preview --
    if (hoverPath && hoverPath.length > 1) {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      const p0 = hexToPixel(hoverPath[0].row, hoverPath[0].col);
      ctx.moveTo(p0.x, p0.y);
      for (let i = 1; i < hoverPath.length; i++) {
        const p = hexToPixel(hoverPath[i].row, hoverPath[i].col);
        ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
      ctx.setLineDash([]);
      // Dots at each waypoint (skip start)
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      for (let i = 1; i < hoverPath.length; i++) {
        const p = hexToPixel(hoverPath[i].row, hoverPath[i].col);
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.lineWidth = 1;
    }

    // -- Units --
    for (const unit of state.units) {
      if (unit.hp <= 0) continue;
      const { x: cx, y: cy } = hexToPixel(unit.row, unit.col);
      const isSelected = unit.id === state.selectedUnitId;
      const isTarget = attackSet.has(unit.id);

      // Attack target overlay
      if (isTarget) {
        this.hexPath(cx, cy, HEX_SIZE);
        ctx.fillStyle = 'rgba(255, 60, 60, 0.4)';
        ctx.fill();
        this.hexPath(cx, cy, HEX_SIZE - 2);
        ctx.strokeStyle = 'rgba(255, 60, 60, 0.8)';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.lineWidth = 1;
      }

      // Selection glow
      if (isSelected) {
        ctx.strokeStyle = '#ffdd00';
        ctx.lineWidth = 3;
        this.hexPath(cx, cy, HEX_SIZE - 2);
        ctx.stroke();
        ctx.lineWidth = 1;
      }

      // Dim spent units
      if (unit.attacked) ctx.globalAlpha = 0.45;
      else if (unit.moved) ctx.globalAlpha = 0.7;

      // Unit icon (team-colored, larger)
      this.drawUnitIcon(ctx, unit.type, cx, cy - 2, unit.team);

      ctx.globalAlpha = 1.0;

      // HP bar
      const barW = HEX_SIZE * 0.9, barH = 4;
      const barX = cx - barW / 2, barY = cy + HEX_SIZE * 0.42;
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(barX - 1, barY - 1, barW + 2, barH + 2);
      const hpPct = unit.hp / UNIT_DEFS[unit.type].hp;
      ctx.fillStyle = hpPct > 0.5 ? '#4c4' : hpPct > 0.25 ? '#cc4' : '#c44';
      ctx.fillRect(barX, barY, barW * hpPct, barH);

      // HP number
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${HEX_SIZE * 0.28}px sans-serif`;
      ctx.fillText(unit.hp, cx + HEX_SIZE * 0.42, barY + 2);
    }

    // -- Tooltip --
    if (tooltipData) this.drawTooltip(tooltipData);
  }

  drawUnitIcon(ctx, type, cx, cy, team) {
    const s = HEX_SIZE * 0.65;
    const isBlue = team === TEAM.BLUE;
    const fill = isBlue ? '#4488dd' : '#dd4444';
    const dark = isBlue ? '#2a5a99' : '#992a2a';
    const outline = '#1a1a2e';
    ctx.save();
    ctx.translate(cx, cy);
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // Drop shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(1, s * 0.55, s * 0.5, s * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();

    switch (type) {
      case 'swordsman': {
        // Blade
        ctx.strokeStyle = '#ccd0d8';
        ctx.lineWidth = s * 0.14;
        ctx.beginPath();
        ctx.moveTo(s * 0.45, -s * 0.85);
        ctx.lineTo(s * 0.45, s * 0.15);
        ctx.stroke();
        // Blade outline
        ctx.strokeStyle = outline;
        ctx.lineWidth = s * 0.04;
        ctx.beginPath();
        ctx.moveTo(s * 0.45, -s * 0.9);
        ctx.lineTo(s * 0.45, s * 0.15);
        ctx.stroke();
        // Crossguard
        ctx.fillStyle = '#665544';
        ctx.fillRect(s * 0.25, s * 0.1, s * 0.4, s * 0.1);
        // Handle
        ctx.strokeStyle = '#665544';
        ctx.lineWidth = s * 0.1;
        ctx.beginPath();
        ctx.moveTo(s * 0.45, s * 0.15);
        ctx.lineTo(s * 0.45, s * 0.35);
        ctx.stroke();
        // Body
        ctx.fillStyle = fill;
        ctx.fillRect(-s * 0.22, -s * 0.15, s * 0.5, s * 0.45);
        ctx.fillStyle = dark;
        ctx.fillRect(-s * 0.25, -s * 0.2, s * 0.55, s * 0.1);
        // Head
        ctx.fillStyle = '#aab0bb';
        ctx.beginPath();
        ctx.arc(0, -s * 0.38, s * 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#8890a0';
        ctx.fillRect(-s * 0.2, -s * 0.38, s * 0.4, s * 0.1);
        // Legs
        ctx.fillStyle = '#6b4c30';
        ctx.fillRect(-s * 0.18, s * 0.3, s * 0.15, s * 0.25);
        ctx.fillRect(s * 0.08, s * 0.3, s * 0.15, s * 0.25);
        break;
      }
      case 'spearman': {
        // Spear shaft
        ctx.strokeStyle = '#8B7355';
        ctx.lineWidth = s * 0.08;
        ctx.beginPath();
        ctx.moveTo(s * 0.15, -s * 0.95);
        ctx.lineTo(s * 0.15, s * 0.5);
        ctx.stroke();
        // Spearhead
        ctx.fillStyle = '#ccd0d8';
        ctx.beginPath();
        ctx.moveTo(s * 0.15, -s * 0.95);
        ctx.lineTo(s * 0.02, -s * 0.7);
        ctx.lineTo(s * 0.28, -s * 0.7);
        ctx.closePath();
        ctx.fill();
        // Body
        ctx.fillStyle = fill;
        ctx.fillRect(-s * 0.22, -s * 0.15, s * 0.45, s * 0.45);
        ctx.fillStyle = dark;
        ctx.fillRect(-s * 0.25, -s * 0.2, s * 0.5, s * 0.1);
        // Head (kettle helm)
        ctx.fillStyle = '#aab0bb';
        ctx.beginPath();
        ctx.arc(0, -s * 0.38, s * 0.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#aab0bb';
        ctx.fillRect(-s * 0.28, -s * 0.32, s * 0.56, s * 0.07);
        // Legs
        ctx.fillStyle = '#6b4c30';
        ctx.fillRect(-s * 0.18, s * 0.3, s * 0.15, s * 0.25);
        ctx.fillRect(s * 0.05, s * 0.3, s * 0.15, s * 0.25);
        break;
      }
      case 'archer': {
        // Bow
        ctx.strokeStyle = '#8B6914';
        ctx.lineWidth = s * 0.1;
        ctx.beginPath();
        ctx.moveTo(-s * 0.35, -s * 0.55);
        ctx.quadraticCurveTo(-s * 0.7, 0, -s * 0.35, s * 0.35);
        ctx.stroke();
        // String
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = s * 0.03;
        ctx.beginPath();
        ctx.moveTo(-s * 0.35, -s * 0.55);
        ctx.lineTo(-s * 0.15, 0);
        ctx.lineTo(-s * 0.35, s * 0.35);
        ctx.stroke();
        // Arrow
        ctx.strokeStyle = '#8B7355';
        ctx.lineWidth = s * 0.05;
        ctx.beginPath();
        ctx.moveTo(-s * 0.15, 0);
        ctx.lineTo(s * 0.55, 0);
        ctx.stroke();
        ctx.fillStyle = '#ccd0d8';
        ctx.beginPath();
        ctx.moveTo(s * 0.65, 0);
        ctx.lineTo(s * 0.48, -s * 0.1);
        ctx.lineTo(s * 0.48, s * 0.1);
        ctx.closePath();
        ctx.fill();
        // Body
        ctx.fillStyle = fill;
        ctx.fillRect(-s * 0.2, -s * 0.12, s * 0.42, s * 0.4);
        ctx.fillStyle = dark;
        ctx.fillRect(-s * 0.22, -s * 0.17, s * 0.46, s * 0.1);
        // Hood
        ctx.fillStyle = fill;
        ctx.beginPath();
        ctx.arc(0, -s * 0.35, s * 0.22, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-s * 0.22, -s * 0.3);
        ctx.lineTo(0, -s * 0.6);
        ctx.lineTo(s * 0.15, -s * 0.3);
        ctx.fill();
        // Face
        ctx.fillStyle = '#e0b888';
        ctx.fillRect(-s * 0.1, -s * 0.35, s * 0.2, s * 0.15);
        // Legs
        ctx.fillStyle = '#6b4c30';
        ctx.fillRect(-s * 0.16, s * 0.28, s * 0.13, s * 0.25);
        ctx.fillRect(s * 0.05, s * 0.28, s * 0.13, s * 0.25);
        break;
      }
      case 'cavalry': {
        // Horse body
        ctx.fillStyle = isBlue ? '#c8b898' : '#8B6544';
        ctx.beginPath();
        ctx.ellipse(0, s * 0.15, s * 0.45, s * 0.22, 0, 0, Math.PI * 2);
        ctx.fill();
        // Horse legs
        const legC = isBlue ? '#a89878' : '#704830';
        ctx.fillStyle = legC;
        ctx.fillRect(-s * 0.32, s * 0.3, s * 0.1, s * 0.25);
        ctx.fillRect(-s * 0.12, s * 0.3, s * 0.1, s * 0.25);
        ctx.fillRect(s * 0.12, s * 0.3, s * 0.1, s * 0.25);
        ctx.fillRect(s * 0.28, s * 0.3, s * 0.1, s * 0.25);
        // Horse head
        ctx.fillStyle = isBlue ? '#c8b898' : '#8B6544';
        ctx.beginPath();
        ctx.moveTo(s * 0.4, s * 0.05);
        ctx.quadraticCurveTo(s * 0.7, -s * 0.1, s * 0.6, -s * 0.35);
        ctx.lineTo(s * 0.45, -s * 0.3);
        ctx.quadraticCurveTo(s * 0.4, -s * 0.05, s * 0.3, s * 0.05);
        ctx.closePath();
        ctx.fill();
        // Horse ear
        ctx.fillStyle = isBlue ? '#b8a888' : '#7a5534';
        ctx.beginPath();
        ctx.moveTo(s * 0.55, -s * 0.35);
        ctx.lineTo(s * 0.6, -s * 0.5);
        ctx.lineTo(s * 0.65, -s * 0.35);
        ctx.closePath();
        ctx.fill();
        // Rider body
        ctx.fillStyle = fill;
        ctx.fillRect(-s * 0.12, -s * 0.25, s * 0.3, s * 0.32);
        ctx.fillStyle = dark;
        ctx.fillRect(-s * 0.15, -s * 0.3, s * 0.35, s * 0.08);
        // Rider head
        ctx.fillStyle = '#aab0bb';
        ctx.beginPath();
        ctx.arc(s * 0.03, -s * 0.45, s * 0.16, 0, Math.PI * 2);
        ctx.fill();
        break;
      }
    }
    ctx.restore();
  }

  drawTooltip({ row, col, lines }) {
    const ctx = this.ctx;
    const { x: hx, y: hy } = hexToPixel(row, col);
    const fontSize = 12;
    const pad = 8;
    const lineH = fontSize + 4;
    ctx.font = `bold ${fontSize}px sans-serif`;

    // Measure width from longest line
    let maxW = 0;
    for (const line of lines) maxW = Math.max(maxW, ctx.measureText(line).width);
    const boxW = maxW + pad * 2;
    const boxH = lines.length * lineH + pad * 2 - 4;

    // Position: offset above-right of hex, flip if near edges
    let bx = hx + HEX_SIZE * 0.6;
    let by = hy - boxH - HEX_SIZE * 0.3;
    if (bx + boxW > this.canvas.width - 4) bx = hx - boxW - HEX_SIZE * 0.6;
    if (by < 4) by = hy + HEX_SIZE * 0.6;

    // Draw background
    ctx.fillStyle = 'rgba(10, 10, 30, 0.88)';
    ctx.strokeStyle = 'rgba(150, 180, 220, 0.5)';
    ctx.lineWidth = 1;
    const r = 4;
    ctx.beginPath();
    ctx.moveTo(bx + r, by);
    ctx.lineTo(bx + boxW - r, by);
    ctx.arcTo(bx + boxW, by, bx + boxW, by + r, r);
    ctx.lineTo(bx + boxW, by + boxH - r);
    ctx.arcTo(bx + boxW, by + boxH, bx + boxW - r, by + boxH, r);
    ctx.lineTo(bx + r, by + boxH);
    ctx.arcTo(bx, by + boxH, bx, by + boxH - r, r);
    ctx.lineTo(bx, by + r);
    ctx.arcTo(bx, by, bx + r, by, r);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.lineWidth = 1;

    // Draw text
    ctx.fillStyle = '#eee';
    ctx.font = `bold ${fontSize}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    for (let i = 0; i < lines.length; i++) {
      ctx.fillText(lines[i], bx + pad, by + pad + i * lineH);
    }
  }

  getCellFromPixel(clientX, clientY) {
    const rect = this.canvas.getBoundingClientRect();
    const scaleX = this.canvas.width / rect.width;
    const scaleY = this.canvas.height / rect.height;
    return pixelToHex((clientX - rect.left) * scaleX, (clientY - rect.top) * scaleY);
  }
}

// ============================================================
//  SOUND MANAGER — Synthesized sound effects via Web Audio API.
//  No external files needed. Call play methods from Controller.
// ============================================================

class SoundManager {
  constructor() {
    this.ctx = null; // AudioContext created on first user interaction
    this.muted = false;
  }

  init() {
    if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    if (this.ctx.state === 'suspended') this.ctx.resume();
  }

  // -- Utility helpers --

  noise(duration, filter, freq, q, gain, type = 'bandpass') {
    if (!this.ctx || this.muted) return;
    const sr = this.ctx.sampleRate;
    const len = sr * duration;
    const buf = this.ctx.createBuffer(1, len, sr);
    const data = buf.getChannelData(0);
    for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;

    const src = this.ctx.createBufferSource();
    src.buffer = buf;

    const filt = this.ctx.createBiquadFilter();
    filt.type = type;
    filt.frequency.value = freq;
    filt.Q.value = q;

    const vol = this.ctx.createGain();
    vol.gain.setValueAtTime(gain, this.ctx.currentTime);
    vol.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

    src.connect(filt).connect(vol).connect(this.ctx.destination);
    src.start();
    src.stop(this.ctx.currentTime + duration);
  }

  tone(freq, duration, gain, waveType = 'sine') {
    if (!this.ctx || this.muted) return;
    const osc = this.ctx.createOscillator();
    osc.type = waveType;
    osc.frequency.value = freq;

    const vol = this.ctx.createGain();
    vol.gain.setValueAtTime(gain, this.ctx.currentTime);
    vol.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

    osc.connect(vol).connect(this.ctx.destination);
    osc.start();
    osc.stop(this.ctx.currentTime + duration);
  }

  // -- Sound effects --

  playAttack(attackerType) {
    this.init();
    if (attackerType === 'swordsman' || attackerType === 'cavalry') {
      // Metallic clang
      this.noise(0.15, 'bandpass', 3200, 5, 0.35);
      this.noise(0.08, 'highpass', 5000, 3, 0.15);
      this.tone(800, 0.06, 0.12, 'square');
    } else {
      // Stab/pierce for spearman and archer
      this.noise(0.1, 'highpass', 4000, 2, 0.3);
      this.tone(1200, 0.04, 0.1, 'sawtooth');
    }
  }

  playCounter(attackerType) {
    this.init();
    // Counter-attack: similar but higher-pitched and quieter
    if (attackerType === 'swordsman' || attackerType === 'cavalry') {
      this.noise(0.12, 'bandpass', 4000, 5, 0.25);
      this.tone(1000, 0.05, 0.08, 'square');
    } else {
      this.noise(0.08, 'highpass', 5000, 2, 0.2);
      this.tone(1500, 0.03, 0.07, 'sawtooth');
    }
  }

  playMove(unitType) {
    this.init();
    if (unitType === 'cavalry') {
      // Gallop: quick succession of thuds
      const t = this.ctx.currentTime;
      for (let i = 0; i < 3; i++) {
        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 90 + (i % 2) * 20;
        const vol = this.ctx.createGain();
        vol.gain.setValueAtTime(0, t + i * 0.08);
        vol.gain.linearRampToValueAtTime(0.2, t + i * 0.08 + 0.01);
        vol.gain.exponentialRampToValueAtTime(0.001, t + i * 0.08 + 0.07);
        osc.connect(vol).connect(this.ctx.destination);
        osc.start(t + i * 0.08);
        osc.stop(t + i * 0.08 + 0.07);
      }
      this.noise(0.25, 'lowpass', 300, 1, 0.1, 'lowpass');
    } else {
      // Footstep: single soft thud
      this.tone(100, 0.1, 0.15, 'sine');
      this.noise(0.08, 'lowpass', 400, 1, 0.08, 'lowpass');
    }
  }

  playDestroy() {
    this.init();
    // Low crumble/collapse
    this.noise(0.3, 'lowpass', 600, 2, 0.3, 'lowpass');
    this.tone(200, 0.15, 0.15, 'sawtooth');
    this.tone(100, 0.3, 0.1, 'sine');
  }
}

// ============================================================
//  GAME CONTROLLER — Wires input, rules, state, and renderer.
//  To add AI: check currentTeam before waiting for clicks.
//  To add networking: sync state after each action.
//  To add save/load: serialize/deserialize GameState.
// ============================================================

class GameController {
  constructor() {
    this.turnInfoEl = document.getElementById('turn-info');
    this.endTurnBtn = document.getElementById('end-turn');
    this.infoPanel = document.getElementById('info-panel');
    this.hoverCell = null;
    this.aiTeam = null;
    this.aiPlayer = null;
    this.aiTurnInProgress = false;
    this.skipAiAnimation = false;
    this._gameId = 0;             // incremented each game to invalidate stale AI timeouts
    this._boundListeners = null;   // stored for cleanup between games
    this.sound = new SoundManager();
    this.setupStartScreen();
    this._setupPermanentButtons();
  }

  /** Help and sound buttons — attach once, never duplicated. */
  _setupPermanentButtons() {
    const helpBtn = document.getElementById('help-btn');
    const helpPanel = document.getElementById('help-panel');
    helpBtn.addEventListener('click', () => {
      const open = helpPanel.style.display !== 'none';
      helpPanel.style.display = open ? 'none' : 'block';
      helpBtn.textContent = open ? 'Help' : 'Hide Help';
    });
    const soundBtn = document.getElementById('sound-btn');
    soundBtn.addEventListener('click', () => {
      this.sound.muted = !this.sound.muted;
      soundBtn.textContent = this.sound.muted ? 'Sound: Off' : 'Sound: On';
    });
  }

  setupStartScreen() {
    this.selectedDifficulty = 'normal';
    this.selectedMapSize = 'medium';
    this.selectedDensity = 'normal';

    // --- Play vs AI ---
    document.getElementById('btn-vs-ai').addEventListener('click', () => {
      document.querySelector('.start-buttons').style.display = 'none';
      document.getElementById('team-pick').style.display = 'flex';
    });
    // Map size toggle (AI)
    for (const btn of document.querySelectorAll('.size-btn')) {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.selectedMapSize = btn.dataset.size;
      });
    }
    // Terrain density toggle (AI)
    for (const btn of document.querySelectorAll('.density-btn')) {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.density-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.selectedDensity = btn.dataset.density;
      });
    }
    // Difficulty toggle
    for (const btn of document.querySelectorAll('.diff-opt')) {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.diff-opt').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.selectedDifficulty = btn.dataset.diff;
      });
    }
    document.getElementById('pick-blue').addEventListener('click', () => this.startGame(TEAM.RED));
    document.getElementById('pick-red').addEventListener('click', () => this.startGame(TEAM.BLUE));
    document.getElementById('pick-back').addEventListener('click', () => {
      document.getElementById('team-pick').style.display = 'none';
      document.querySelector('.start-buttons').style.display = 'flex';
    });

    // --- 2P Hotseat ---
    document.getElementById('btn-hotseat').addEventListener('click', () => {
      document.querySelector('.start-buttons').style.display = 'none';
      document.getElementById('hotseat-pick').style.display = 'flex';
    });
    // Map size toggle (Hotseat)
    for (const btn of document.querySelectorAll('.hs-size-btn')) {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.hs-size-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.selectedMapSize = btn.dataset.size;
      });
    }
    // Terrain density toggle (Hotseat)
    for (const btn of document.querySelectorAll('.hs-density-btn')) {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.hs-density-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.selectedDensity = btn.dataset.density;
      });
    }
    document.getElementById('hs-start').addEventListener('click', () => this.startGame(null));
    document.getElementById('hs-back').addEventListener('click', () => {
      document.getElementById('hotseat-pick').style.display = 'none';
      document.querySelector('.start-buttons').style.display = 'flex';
    });

    // --- About ---
    document.getElementById('btn-about').addEventListener('click', () => {
      document.getElementById('about-overlay').style.display = 'flex';
    });
    document.getElementById('about-close').addEventListener('click', () => {
      document.getElementById('about-overlay').style.display = 'none';
    });
  }

  startGame(aiTeam) {
    // Invalidate any stale AI timeouts from previous game
    this._gameId++;
    this.cleanupInput();

    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('header').style.display = 'flex';
    document.getElementById('game').style.display = 'block';
    this.infoPanel.style.display = 'block';

    // Set grid dimensions from selected map size
    const sizeKey = this.selectedMapSize || 'medium';
    const preset = MAP_SIZES[sizeKey];
    ROWS = preset.rows;
    COLS = preset.cols;
    recalcCanvasDims();

    this.aiTeam = aiTeam;
    this.aiTurnInProgress = false;
    this.skipAiAnimation = false;
    this.hoverCell = null;
    this.state = this.createInitialState(preset);
    const canvas = document.getElementById('game');
    this.renderer = new CanvasRenderer(canvas);

    const w = canvas.width + 'px';
    document.getElementById('header').style.width = w;
    this.infoPanel.style.width = w;
    document.getElementById('help-panel').style.width = w;

    if (aiTeam) {
      this.aiPlayer = new AIPlayer(aiTeam, this.selectedDifficulty || 'normal');
    } else {
      this.aiPlayer = null;
    }

    this.bindInput();
    this.updateUI();

    // If AI goes first (player chose Red), kick off AI turn
    if (this.aiTeam === TEAM.BLUE) {
      setTimeout(() => this.runAiTurn(), 500);
    }
  }

  returnToStart() {
    // Invalidate stale AI timeouts and remove event listeners
    this._gameId++;
    this.cleanupInput();

    document.getElementById('start-screen').style.display = 'flex';
    document.querySelector('.start-buttons').style.display = 'flex';
    document.getElementById('team-pick').style.display = 'none';
    document.getElementById('hotseat-pick').style.display = 'none';
    document.getElementById('header').style.display = 'none';
    document.getElementById('game').style.display = 'none';
    this.infoPanel.style.display = 'none';
    document.getElementById('help-panel').style.display = 'none';
    document.getElementById('help-btn').textContent = 'Help';
    this.endTurnBtn.textContent = 'End Turn';
    this.endTurnBtn.disabled = false;
    this.aiTeam = null;
    this.aiPlayer = null;
    this.aiTurnInProgress = false;
    this.skipAiAnimation = false;
    this.hoverCell = null;
    this._moveParentMap = null;
    this.state = null;
    this.renderer = null;
  }

  createInitialState(preset) {
    const map = generateMap(ROWS, COLS, this.selectedDensity);
    const units = generateUnits(preset, ROWS, COLS);
    return GameState.createInitial(map, units);
  }

  // -- Input binding (swap this section for AI/network input) --

  /** Remove all game-session event listeners. Safe to call even if none are bound. */
  cleanupInput() {
    if (!this._boundListeners) return;
    const b = this._boundListeners;
    b.canvas.removeEventListener('click', b.onClick);
    b.canvas.removeEventListener('mousemove', b.onMouseMove);
    b.canvas.removeEventListener('mouseleave', b.onMouseLeave);
    b.canvas.removeEventListener('touchstart', b.onTouchStart);
    b.canvas.removeEventListener('touchmove', b.onTouchMove);
    b.canvas.removeEventListener('touchend', b.onTouchEnd);
    document.removeEventListener('keydown', b.onKeyDown);
    this.endTurnBtn.onclick = null;
    this._boundListeners = null;
  }

  bindInput() {
    const canvas = this.renderer.canvas;
    let lpTimer = null;
    let lpFired = false;

    const b = {
      canvas,
      onClick: (e) => {
        if (this.state.winner || this.aiTurnInProgress) return;
        if (this.aiTeam && this.state.currentTeam === this.aiTeam) return;
        const cell = this.renderer.getCellFromPixel(e.clientX, e.clientY);
        if (cell) this.handleClick(cell.row, cell.col);
      },
      onMouseMove: (e) => {
        this.hoverCell = this.renderer.getCellFromPixel(e.clientX, e.clientY);
        this.renderOnly();
      },
      onMouseLeave: () => {
        this.hoverCell = null;
        this.renderOnly();
      },
      onKeyDown: (e) => {
        if (e.key === 'Escape') {
          if (this.aiTurnInProgress) {
            this.skipAiAnimation = true;
          } else {
            this.cancelSelection();
            this.updateUI();
          }
        }
        if (e.key === ' ' && this.aiTurnInProgress) {
          e.preventDefault();
          this.skipAiAnimation = true;
        }
      },
      onTouchStart: (e) => {
        if (e.touches.length !== 1) return;
        lpFired = false;
        const touch = e.touches[0];
        const cell = this.renderer.getCellFromPixel(touch.clientX, touch.clientY);
        lpTimer = setTimeout(() => {
          if (cell) {
            this.hoverCell = cell;
            lpFired = true;
            this.renderOnly();
          }
        }, 400);
      },
      onTouchMove: () => {
        clearTimeout(lpTimer);
        if (lpFired) { lpFired = false; this.hoverCell = null; this.renderOnly(); }
      },
      onTouchEnd: (e) => {
        clearTimeout(lpTimer);
        if (lpFired) {
          lpFired = false;
          this.hoverCell = null;
          this.renderOnly();
          e.preventDefault();
        }
      },
    };

    canvas.addEventListener('click', b.onClick);
    canvas.addEventListener('mousemove', b.onMouseMove);
    canvas.addEventListener('mouseleave', b.onMouseLeave);
    canvas.addEventListener('touchstart', b.onTouchStart, { passive: true });
    canvas.addEventListener('touchmove', b.onTouchMove, { passive: true });
    canvas.addEventListener('touchend', b.onTouchEnd);
    document.addEventListener('keydown', b.onKeyDown);
    this.endTurnBtn.onclick = () => {
      if (this.state.winner || this.aiTurnInProgress) return;
      if (this.aiTeam && this.state.currentTeam === this.aiTeam) return;
      this.doEndTurn();
    };
    this._boundListeners = b;
  }

  // -- Action handlers --

  handleClick(row, col) {
    const s = this.state;
    if      (s.phase === PHASE.SELECT) this.doSelect(row, col);
    else if (s.phase === PHASE.MOVE)   this.doMove(row, col);
    else if (s.phase === PHASE.ATTACK) this.doAttack(row, col);
  }

  doSelect(row, col) {
    const s = this.state;
    const unit = s.getUnitAt(row, col);
    if (!unit || unit.team !== s.currentTeam) return;
    if (unit.moved && unit.attacked) return; // fully done

    s.selectedUnitId = unit.id;

    if (unit.moved && !unit.attacked) {
      // Already moved — attack phase only
      const targets = GameRules.getAttackTargets(s, unit);
      if (targets.length > 0) {
        s.highlightedAttacks = targets.map(t => t.id);
        s.phase = PHASE.ATTACK;
        this.setInfo(`${UNIT_DEFS[unit.type].name}: click an enemy to attack, or elsewhere to wait.`);
      } else {
        this.cancelSelection();
        this.setInfo(`${UNIT_DEFS[unit.type].name}: no targets in range.`);
      }
    } else {
      // Can move — show movement range
      this._moveParentMap = new Map();
      s.highlightedMoves = GameRules.getMovableCells(s, unit, this._moveParentMap);
      // If hasn't attacked yet, also show attack targets (fire before move)
      if (!unit.attacked) {
        const targets = GameRules.getAttackTargets(s, unit);
        s.highlightedAttacks = targets.map(t => t.id);
      }
      s.phase = PHASE.MOVE;
      const name = UNIT_DEFS[unit.type].name;
      if (unit.attacked) {
        this.setInfo(`${name}: click a cell to move, or elsewhere to cancel.`);
      } else {
        this.setInfo(`${name} selected (HP: ${unit.hp}). Move, attack an adjacent enemy, or click elsewhere to cancel.`);
      }
    }
    this.updateUI();
  }

  doMove(row, col) {
    const s = this.state;
    const unit = s.getUnit(s.selectedUnitId);

    // Fire before move — click an adjacent enemy
    const target = s.getUnitAt(row, col);
    if (target && s.highlightedAttacks.includes(target.id)) {
      this.performAttack(unit, target);
      return;
    }

    // Click own unit = deselect
    if (row === unit.row && col === unit.col) {
      this.cancelSelection();
      this.updateUI();
      return;
    }

    // Valid move destination
    if (s.highlightedMoves.some(c => c.row === row && c.col === col)) {
      this.sound.playMove(unit.type);
      GameRules.moveUnit(s, unit.id, row, col);
      unit.moved = true;
      const name = UNIT_DEFS[unit.type].name;
      if (!unit.attacked) {
        const targets = GameRules.getAttackTargets(s, unit);
        if (targets.length > 0) {
          s.highlightedMoves = [];
          s.highlightedAttacks = targets.map(t => t.id);
          s.phase = PHASE.ATTACK;
          this.setInfo(`${name} moved. Click an enemy to attack, or elsewhere to cancel.`);
          this.updateUI();
          return;
        }
      }
      this.cancelSelection();
      this.setInfo(`${name} moved.`);
      this.checkAllActed();
      this.updateUI();
      return;
    }

    // Clicked elsewhere — cancel and try selecting what was clicked
    this.cancelSelection();
    this.doSelect(row, col);
  }

  doAttack(row, col) {
    const s = this.state;
    const attacker = s.getUnit(s.selectedUnitId);
    const target = s.getUnitAt(row, col);

    if (target && s.highlightedAttacks.includes(target.id)) {
      this.performAttack(attacker, target);
    } else if (row === attacker.row && col === attacker.col) {
      // Click own unit = deselect
      this.cancelSelection();
      this.updateUI();
    } else {
      // Click elsewhere — cancel, try selecting what was clicked
      this.cancelSelection();
      this.doSelect(row, col);
    }
  }

  /** Shared combat resolution for both fire-before-move and fire-after-move. */
  performAttack(attacker, target) {
    const s = this.state;
    const result = GameRules.resolveAttack(s, attacker.id, target.id);

    // Sound effects
    this.sound.playAttack(attacker.type);
    if (result.counterDamage > 0) {
      setTimeout(() => this.sound.playCounter(target.type), 120);
    }
    if (result.defenderDestroyed || result.attackerDestroyed) {
      setTimeout(() => this.sound.playDestroy(), 150);
    }

    const flankLabel = result.flankBonus === FLANKING.BACKSTAB ? 'backstab' : 'flanking';
    let msg = `${TEAM_NAME[attacker.team]} ${UNIT_DEFS[attacker.type].name} deals ${result.damage} dmg`;
    if (result.flankBonus > 0) msg += ` [${flankLabel} +${result.flankBonus}%]`;
    if (result.defenderDestroyed) {
      msg += ` — ${UNIT_DEFS[target.type].name} destroyed!`;
    } else {
      msg += ` (enemy HP: ${target.hp})`;
      if (result.counterDamage > 0) {
        msg += `. Counter-attack: ${result.counterDamage} dmg`;
        if (result.attackerDestroyed) {
          msg += ` — ${UNIT_DEFS[attacker.type].name} destroyed!`;
        } else {
          msg += ` (HP: ${attacker.hp})`;
        }
      }
    }

    attacker.attacked = true;
    this.cancelSelection();

    const winner = GameRules.checkWinner(s);
    if (winner) {
      s.winner = winner;
      this.setInfo(`${TEAM_NAME[s.winner]} team wins!`);
    } else {
      if (!attacker.moved && attacker.hp > 0) msg += ' Select again to move.';
      this.setInfo(msg);
      this.checkAllActed();
    }
    this.updateUI();
  }

  doEndTurn() {
    GameRules.endTurn(this.state);
    this.setInfo(`${TEAM_NAME[this.state.currentTeam]}'s turn. Select a unit.`);
    this.updateUI();

    // Trigger AI turn if it's the AI's team
    if (this.aiTeam && this.state.currentTeam === this.aiTeam && !this.state.winner) {
      this.runAiTurn();
    }
  }

  // -- AI Turn Execution --

  async runAiTurn() {
    if (!this.aiPlayer || this.state.currentTeam !== this.aiTeam) return;
    this.aiTurnInProgress = true;
    this.skipAiAnimation = false;
    this.endTurnBtn.disabled = true;
    this.setInfo(`${TEAM_NAME[this.aiTeam]} is thinking... (Space/Esc to skip)`);
    this.updateUI();

    try {
      const actions = this.aiPlayer.planTurn(this.state);

      for (const action of actions) {
        if (this.state.winner) break;
        const unit = this.state.getUnit(action.unitId);
        if (!unit || unit.hp <= 0) continue;

        // Highlight the acting unit
        this.state.selectedUnitId = action.unitId;
        this.state.highlightedMoves = [];
        this.state.highlightedAttacks = [];
        this.updateUI();
        await this.aiDelay(400);

        // Pre-move attack
        if (action.attackBeforeMove && action.attackTargetId !== null) {
          const target = this.state.getUnit(action.attackTargetId);
          if (target && target.hp > 0) {
            this.state.highlightedAttacks = [action.attackTargetId];
            this.updateUI();
            await this.aiDelay(300);
            this.performAttack(unit, target);
            await this.aiDelay(500);
          }
        }

        if (this.state.winner) break;

        // Move
        if (action.move && unit.hp > 0) {
          this.state.highlightedMoves = [action.move];
          this.updateUI();
          await this.aiDelay(300);
          this.sound.playMove(unit.type);
          GameRules.moveUnit(this.state, unit.id, action.move.row, action.move.col);
          unit.moved = true;
          this.cancelSelection();
          this.state.selectedUnitId = action.unitId;
          this.updateUI();
          await this.aiDelay(300);
        }

        // Post-move attack
        if (!action.attackBeforeMove && action.attackTargetId !== null && unit.hp > 0) {
          const target = this.state.getUnit(action.attackTargetId);
          if (target && target.hp > 0) {
            this.state.highlightedAttacks = [action.attackTargetId];
            this.updateUI();
            await this.aiDelay(300);
            this.performAttack(unit, target);
            await this.aiDelay(500);
          }
        }

        // Clear selection after this unit's action
        this.cancelSelection();
        this.updateUI();
        await this.aiDelay(200);
      }

      // End AI turn
      if (!this.state.winner) {
        this.doEndTurn();
      }
      this.aiTurnInProgress = false;
      if (!this.state.winner) {
        this.endTurnBtn.disabled = false;
      }
    } catch (e) {
      // Game ended mid-turn (user clicked New Game) — silently abort
      if (e.message === 'game ended') return;
      throw e;
    }
  }

  aiDelay(ms) {
    if (this.skipAiAnimation) return Promise.resolve();
    const gid = this._gameId;
    return new Promise((resolve, reject) => setTimeout(() => {
      if (this._gameId !== gid) reject(new Error('game ended'));
      else resolve();
    }, ms));
  }

  // -- Helpers --

  cancelSelection() {
    const s = this.state;
    s.selectedUnitId = null;
    s.highlightedMoves = [];
    s.highlightedAttacks = [];
    s.phase = PHASE.SELECT;
    this._moveParentMap = null;
  }

  checkAllActed() {
    const s = this.state;
    if (s.getLivingUnits(s.currentTeam).every(u => u.attacked)) {
      this.setInfo(this.infoPanel.textContent + ' All units done — click End Turn.');
    }
  }

  setInfo(text) { this.infoPanel.textContent = text; }

  computeTooltip() {
    const s = this.state;
    if (!this.hoverCell || s.winner) return null;
    const { row, col } = this.hoverCell;
    const hoveredUnit = s.getUnitAt(row, col);

    // Attack preview: hovering a valid target while a unit is selected
    if (hoveredUnit && s.selectedUnitId !== null && s.highlightedAttacks.includes(hoveredUnit.id)) {
      const atk = s.getUnit(s.selectedUnitId);
      const def = hoveredUnit;
      const defTerrain = s.map[def.row][def.col];
      const atkTerrain = s.map[atk.row][atk.col];

      const baseDmg = GameRules.calculateDamage(atk.type, atk.hp, def.type, defTerrain);
      const flankBonus = GameRules.getFlankingBonus(s, atk, def);
      const damage = flankBonus > 0 ? Math.max(1, Math.round(baseDmg * (100 + flankBonus) / 100)) : baseDmg;
      const defHpAfter = Math.max(0, def.hp - damage);

      const lines = [`${UNIT_DEFS[atk.type].name} \u2192 ${UNIT_DEFS[def.type].name}`];
      let dmgLine = `Damage: ${damage}`;
      if (flankBonus > 0) {
        const label = flankBonus === FLANKING.BACKSTAB ? 'backstab' : 'flanking';
        dmgLine += `  [${label} +${flankBonus}%]`;
      }
      lines.push(dmgLine);

      // Counter-attack preview
      const dist = hexDistance(atk.row, atk.col, def.row, def.col);
      if (defHpAfter > 0 && dist <= UNIT_DEFS[def.type].range) {
        const counterDmg = GameRules.calculateDamage(def.type, defHpAfter, atk.type, atkTerrain);
        const atkHpAfter = Math.max(0, atk.hp - counterDmg);
        lines.push(`Counter: ${counterDmg}`);
        lines.push(`Result: ${atkHpAfter} HP / ${defHpAfter} HP`);
      } else {
        lines.push(`Result: ${defHpAfter} HP`);
      }

      return { row, col, lines };
    }

    // Unit info: hovering any living unit
    if (hoveredUnit) {
      const def = UNIT_DEFS[hoveredUnit.type];
      const terrain = TERRAIN_DEFS[s.map[row][col]];
      const lines = [
        `${def.name} (${TEAM_NAME[hoveredUnit.team]})`,
        `HP: ${hoveredUnit.hp}/${def.hp}`,
      ];
      if (terrain.defense > 0) lines.push(`${terrain.name}: +${terrain.defense}% def`);
      return { row, col, lines };
    }

    return null;
  }

  computeHoverPath() {
    if (!this._moveParentMap || !this.hoverCell) return null;
    const s = this.state;
    if (s.phase !== PHASE.MOVE) return null;
    const { row, col } = this.hoverCell;
    if (!s.highlightedMoves.some(c => c.row === row && c.col === col)) return null;
    const unit = s.getUnit(s.selectedUnitId);
    if (row === unit.row && col === unit.col) return null;
    return GameRules.reconstructPath(this._moveParentMap, row, col);
  }

  renderOnly() { this.renderer.render(this.state, this.hoverCell, this.computeTooltip(), this.computeHoverPath()); }

  updateUI() {
    const s = this.state;
    const color = TEAM_COLOR[s.currentTeam];
    if (s.winner) {
      this.turnInfoEl.innerHTML = `<span style="color:${TEAM_COLOR[s.winner]}">${TEAM_NAME[s.winner]} Wins!</span>`;
      this.endTurnBtn.textContent = 'New Game';
      this.endTurnBtn.disabled = false;
      this.endTurnBtn.style.background = '#555';
      this.endTurnBtn.style.color = '#fff';
      this.endTurnBtn.onclick = () => this.returnToStart();
    } else {
      this.turnInfoEl.innerHTML = `Turn ${s.turnNumber} — <span style="color:${color}">${TEAM_NAME[s.currentTeam]}</span>`;
      this.endTurnBtn.style.background = color;
      this.endTurnBtn.style.color = '#fff';
      this.endTurnBtn.disabled = this.aiTurnInProgress;
    }
    this.renderer.render(this.state, this.hoverCell, this.computeTooltip(), this.computeHoverPath());
  }
}

// ============================================================
//  BOOT
// ============================================================

const game = new GameController();
</script>
</body>
</html>
